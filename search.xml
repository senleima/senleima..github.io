<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap底层实现原理</title>
    <url>/2021/11/10/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="HashMap底层实现原理"><a href="#HashMap底层实现原理" class="headerlink" title="HashMap底层实现原理"></a>HashMap底层实现原理</h1><p>HashMap底层实现采用了哈希表，这是一种非常重要的数据结构，对于理解很多技术都非常有帮助(比如：redis数据库的核心技术和HashMap一样)。</p>
<p>数据结构中由数组和链表来实现对数据的存储，他们各有不同的特点。</p>
<p>(1) 数组：占用空间连续。 寻址容易，查询速度快。但增加和删除效率非常低。</p>
<p>(2) 链表：占用空间不连续。 寻址困难，查询速度慢。但增加和删除效率非常高。</p>
<p>哈希表的本质就是“数组+链表”，结合了数组和链表的优点(即查询快，增删效率高)。</p>
<h2 id="HashMap基本结构"><a href="#HashMap基本结构" class="headerlink" title="HashMap基本结构"></a>HashMap基本结构</h2><p>HashMap源码有如下两个核心内容：</p>
<pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; 
   implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;
    /**
     * The default initial capacity - MUST be a power of two.
     * 核心数组默认初始化的大小为16（数组大小必须为2的整数幂）。
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
    
    /**
     * The load factor used when none specified in constructor.、
     * 负载因子（核心数组被占用超过0.75则自动开始扩容）。
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    
    /**
     * The table, initialized on first use, and resized as
     * necessary. When allocated, length is always a power of two.
     * (We also tolerate length zero in some operations to allow
     * bootstrapping mechanics that are currently not needed.)
     * 核心数组（根据需要可以扩容）。数组长度必须始终为2的整数幂。
     */
    transient Node&lt;K,V&gt;[] table;
    //以下代码省略
&#125;
</code></pre>
<p>其中的Node&lt;K,V&gt;[] table 就是HashMap的核心数组结构，也称之为“位桶数组”。Node&lt;K,V&gt;源码如下：</p>
<pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;

    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    &#125;
    //以下代码省略
&#125;
</code></pre>
<p>一个Node&lt;K,V&gt;对象存储了：</p>
<p>(1)key：键对象  value：值对象</p>
<p>(2)next：下一个节点</p>
<p>(3)hash：键对象的hash值</p>
<p>每一个Node&lt;K,V&gt;对象都是一个单向链表结构，如下表示一个Node&lt;K,V&gt;对象的典型示意：</p>
<p><img src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/Node%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="Node对象存储结构"></p>
<p>如下为Node&lt;K,V&gt;[]数组的结构(也是HashMap的结构)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/Node%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="Node数组存储结构"></p>
<h2 id="存储数据过程put-key-value"><a href="#存储数据过程put-key-value" class="headerlink" title="存储数据过程put(key,value)"></a><strong>存储数据过程put(key,value)</strong></h2><p>HashMap存储数据的核心是如何产生hash值，该值用来对应数组的存储位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/HashMap%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B.png" alt="HashMap存储数据过程"></p>
<p>我们的目的是将”key-value两个对象”成对存放到HashMap的Node&lt;K,V&gt;[]数组中。步骤如下：</p>
<p>(1) 获得key对象的hashcode</p>
<p>​      首先调用key对象的hashcode()方法，获得hashcode。</p>
<p>(2) 根据hashcode计算出hash值(要求在[0, 数组长度-1]区间)</p>
<p>​      hashcode是一个整数，需要将它转化成[0, 数组长度-1]的范围。我们要求转化后的hash值尽量均匀地分布在[0,数组长度-1]这个区间，减少“hash冲突”。</p>
<p>​      i. 一种极端简单和低下的算法是：</p>
<p>​      hash值 = hashcode/hashcode;</p>
<p>​      也就是说hash值总是1。意味着键值对对象都会存储到数组索引1位置，这样就形成一个非常长的链表。相当于每存储一个对象都会发生“hash冲突”，HashMap也退化成了一个“链表”。</p>
<p>​      ii. 一种简单和常用的算法是(相除取余算法)：</p>
<p>​      hash值 = hashcode%数组长度</p>
<p>这种算法可以让hash值均匀地分布在[0,数组长度-1]的区间。 早期的HashTable就是采用这种算法。但是，这种算法由于使用了“除法”，效率低下。JDK后来改进了算法。首先约定数组长度必须为2的整数幂，这样采用位运算即可实现取余的效果：hash值 = hashcode&amp;(数组长度-1)。</p>
<p>​      iii. 如下为自己测试简单的hash算法：</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        int h = 25760399;
        int length = 16;//length为2的整数次幂,则h&amp;(length-1)相当于对length取模
        System.out.println(myHash(h, length));
    &#125;
    /**
     * @param h  任意整数
     * @param length 长度必须为2的整数幂
     * @return
     */
    public static int myHash(int h,int length)&#123;
        System.out.println(h&amp;(length-1));
        //length为2的整数幂情况下，和取余的值一样
        System.out.println(h%length);//取余数
        return h&amp;(length-1);
    &#125;
&#125;
</code></pre>
<p>运行如上程序，就能发现直接取余(h%length)和位运算(h&amp;(length-1))结果是一致的。事实上，为了获得更好的散列效果，JDK对hashcode进行了两次散列处理(核心目标就是为了分布更散更均匀)。</p>
<p>(3) 生成Node&lt;K,V&gt;对象</p>
<p>​     如上所述，一个Node&lt;K,V&gt;对象包含4部分：key对象、value对象、hash值、指向下一个Node&lt;K,V&gt;对象的引用。我们现在算出了hash值。下一个Node&lt;K,V&gt;对象的引用为null。</p>
<p>(4) 将Node&lt;K,V&gt;对象放到table数组中</p>
<p>​     如果本Node&lt;K,V&gt;对象对应的数组索引位置还没有放Node&lt;K,V&gt;对象，则直接将Node&lt;K,V&gt;对象存储进数组;如果对应索引位置已经有Node&lt;K,V&gt;对象，则将已有Node&lt;K,V&gt;对象的next指向本Node&lt;K,V&gt;对象，形成链表。</p>
<h3 id="总结如上过程"><a href="#总结如上过程" class="headerlink" title="总结如上过程"></a><strong>总结如上过程</strong></h3><p>   当添加一个元素(key-value)时，首先计算key的hash值，以此确定插入数组中的位置，但可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，就形成了链表，同一个链表上的hash值是相同的，所以说数组存放的是链表。 JDK8中，当链表长度大于8时，链表就转换为红黑树，大大提高了查找的效率。</p>
<h2 id="取数据过程get-key"><a href="#取数据过程get-key" class="headerlink" title="取数据过程get(key)"></a>取数据过程get(key)</h2><p>   我们需要通过key对象获得“键值对”对象，进而返回value对象。步骤如下：</p>
<p>   (1) 获得key的hashcode，通过hash()散列算法得到hash值，进而定位到数组的位置。</p>
<p>   (2) 在链表上挨个比较key对象。 调用equals()方法，将key对象和链表上所有节点的key对象进行比较，直到碰到返回true的节点对象为止。</p>
<p>   (3) 返回equals()为true的节点对象的value对象。</p>
<p>   明白了存取数据的过程，下面再看下hashcode()和equals方法的关系：</p>
<p>   Java中规定，两个内容相同(equals()为true)的对象必须具有相等的hashcode。因为如果equals()为true而两个对象的hashcode不同，那在整个存储过程中就发生了悖论。</p>
<h2 id="扩容问题"><a href="#扩容问题" class="headerlink" title="扩容问题"></a><strong>扩容问题</strong></h2><p>   HashMap的位桶数组，初始大小为16。实际使用时大小是可变的。如果位桶数组中的元素达到(0.75*数组 length)， 则重新调整数组大小变为原来2倍大小。</p>
<p>   扩容很耗时，扩容的本质是定义新的更大的数组，并将旧数组内容挨个拷贝到新数组中。</p>
<h2 id="JDK8将链表在大于8情况下变为红黑二叉树"><a href="#JDK8将链表在大于8情况下变为红黑二叉树" class="headerlink" title="JDK8将链表在大于8情况下变为红黑二叉树"></a><strong>JDK8将链表在大于8情况下变为红黑二叉树</strong></h2><p>   JDK8中，HashMap在存储一个元素时，当对应链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>IO文件拷贝与对接流</title>
    <url>/2022/01/01/IO%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%AF%B9%E6%8E%A5%E6%B5%81/</url>
    <content><![CDATA[<h1 id="IO文件拷贝与对接流"><a href="#IO文件拷贝与对接流" class="headerlink" title="IO文件拷贝与对接流"></a>IO文件拷贝与对接流</h1><h2 id="IO文件拷贝"><a href="#IO文件拷贝" class="headerlink" title="IO文件拷贝"></a>IO文件拷贝</h2><p>IO文件拷贝：文件字节输入输出流。</p>
<ol>
<li>创建源</li>
<li>选择流</li>
<li>操作</li>
<li>释放资源</li>
</ol>
<p>代码如下：</p>
<pre><code class="java">package com.msl.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * 文件拷贝：文件字节输入、输出流
 * 1、创建源
 * 2、选择流
 * 3、操作（写出内容）
 * 4、释放资源
 * @author Senley
 *
 */
public class Copy &#123;

    public static void main(String[] args) &#123;
        copy(&quot;src/com/msl/io/Copy.java&quot;,&quot;copy.txt&quot;);
    &#125;
    /**
     * 文件的拷贝
     * @param srcPath
     * @param destPath
     */
    public static void copy(String srcPath,String destPath) &#123;
        //1、创建源
        File src = new File(srcPath);//源头
        File dest = new File(destPath);//目的地
        //2、选择流
        InputStream is = null;
        OutputStream os = null;
        try &#123;
            is = new FileInputStream(src);
            os = new FileOutputStream(dest);
            //3、操作
            byte[] flush = new byte[1024];//缓冲容器
            int len = -1;//接收长度
            while((len=is.read(flush))!=-1) &#123;
                os.write(flush,0,len);
            &#125;
        &#125;catch(FileNotFoundException e)&#123;
            e.printStackTrace();
        &#125;catch(IOException e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            //释放资源 分别关闭 先打开的后关闭
            try &#123;
                if (null != os) &#123;
                    os.close();
                &#125; 
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
            
            try &#123;
                if(null!=is) &#123;
                    is.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

&#125;
</code></pre>
<h2 id="IO对接流"><a href="#IO对接流" class="headerlink" title="IO对接流"></a>IO对接流</h2><ol>
<li><p>图片读取到字节数组</p>
<p>1)图片到程序</p>
<p>2)程序到字节数组</p>
</li>
<li><p>字节数组写出到文件</p>
<p>1)字节数组到程序</p>
<p>2)程序到文件</p>
</li>
</ol>
<p>代码如下：</p>
<pre><code class="java">package com.msl.io;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * 1、图片读取到字节数组
 * 2、字节数组写出到文件
 * @author Senley
 *
 */
public class IOTest &#123;

    public static void main(String[] args) &#123;
        //图片转成字节数组
        byte[] datas = fileToByteArray(&quot;p.png&quot;);
        System.out.println(datas.length);
        byteArrayToFile(datas, &quot;p-byte.png&quot;);
    &#125;
    
    /**
     * 1、图片读取到字节数组
     * 1)、图片到程序 FileInputStream
     * 2)、程序到字节数组 ByteArrayOutputStream
     */
    public static byte[] fileToByteArray(String filePath) &#123;
        //1、创建源与目的地
        File src = new File(filePath);
        byte[] dest = null;
        //2、选择流
        InputStream is = null;
        ByteArrayOutputStream baos = null;
        try &#123;
            is = new FileInputStream(src);
            baos = new ByteArrayOutputStream();
            //3、操作（分段读取）
            byte[] flush = new byte[1024*10];//缓冲容器
            int len = -1;//接收长度
            while((len=is.read(flush))!=-1) &#123;
                baos.write(flush,0,len); //写出到字节数组中
            &#125;
            baos.flush();
            return baos.toByteArray();
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            //4、释放资源
            try &#123;
                if(null!=is) &#123;
                    is.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        return null;
    &#125;
    /**
     * 2、字节数组写出到文件
     * 1)、字节数组到程序 ByteArrayInputStream
     * 2)、程序到文件 FileOutputStream
     */
    public static void byteArrayToFile(byte[] src,String filePath) &#123;
        //1、创建源
        File dest = new File(filePath);
        //2、选择流
        InputStream is = null;
        OutputStream os = null;
        try &#123;
            is = new ByteArrayInputStream(src);
            os = new FileOutputStream(dest);
            //3、操作（分段读取）
            byte[] flush = new byte[5];//缓冲容器
            int len = -1;//接收长度
            while((len=is.read(flush))!=-1) &#123;
                os.write(flush,0,len);//写出到文件
            &#125;
            os.flush();
        &#125;catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            //4、释放资源
            try &#123;
                if (null != os) &#123;
                    os.close();
                &#125; 
            &#125; catch (Exception e) &#123;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>使用容器存储表格数据</title>
    <url>/2021/11/22/%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="使用容器存储表格数据"><a href="#使用容器存储表格数据" class="headerlink" title="使用容器存储表格数据"></a><strong>使用容器存储表格数据</strong></h1><p>使用容器存储以下表格数据。</p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">姓名</th>
<th align="center">薪水</th>
<th align="center">入职日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1001</td>
<td align="center">张三</td>
<td align="center">20000</td>
<td align="center">2018.5.5</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">李四</td>
<td align="center">30000</td>
<td align="center">2005.5.4</td>
</tr>
<tr>
<td align="center">1003</td>
<td align="center">王五</td>
<td align="center">3000</td>
<td align="center">2020.5.4</td>
</tr>
</tbody></table>
<h2 id="Map和List结合存储"><a href="#Map和List结合存储" class="headerlink" title="Map和List结合存储"></a>Map和List结合存储</h2><p>Map表示一行数据，多行数据是多个Map，将多个Map放到List中。代码如下：</p>
<pre><code class="java">package com.msl.collection;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * 测试表格数据的存储
 * ORM思想的简单实验：map表示一行数据，多行数据是多个map；将多个map放到list中
 * @author Senley
 *
 */
public class TestStoreData &#123;
    public static void main(String[] args) &#123;
        Map&lt;String,Object&gt; row1 = new HashMap&lt;&gt;();
        row1.put(&quot;id&quot;, 1001);
        row1.put(&quot;姓名&quot;, &quot;张三&quot;);
        row1.put(&quot;薪水&quot;, 20000);
        row1.put(&quot;入职日期&quot;, &quot;2018.5.5&quot;);
        
        Map&lt;String,Object&gt; row2 = new HashMap&lt;&gt;();
        row2.put(&quot;id&quot;, 1002);
        row2.put(&quot;姓名&quot;, &quot;李四&quot;);
        row2.put(&quot;薪水&quot;, 30000);
        row2.put(&quot;入职日期&quot;, &quot;2005.4.4&quot;);
        
        Map&lt;String,Object&gt; row3 = new HashMap&lt;&gt;();
        row3.put(&quot;id&quot;, 1003);
        row3.put(&quot;姓名&quot;, &quot;王五&quot;);
        row3.put(&quot;薪水&quot;, 3000);
        row3.put(&quot;入职日期&quot;, &quot;2020.5.4&quot;);
        
        List&lt;Map&lt;String,Object&gt;&gt; table1 = new ArrayList&lt;&gt;();
        table1.add(row1);
        table1.add(row2);
        table1.add(row3);
        
        for(Map&lt;String,Object&gt; row:table1) &#123;
            Set&lt;String&gt; keyset = row.keySet();
            for(String key:keyset) &#123;
                System.out.print(key+&quot;:&quot;+row.get(key)+&quot;\t&quot;);
            &#125;
            System.out.println();
        &#125;
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">姓名:张三    薪水:20000    id:1001    入职日期:2018.5.5    
姓名:李四    薪水:30000    id:1002    入职日期:2005.4.4    
姓名:王五    薪水:3000    id:1003    入职日期:2020.5.4    
</code></pre>
<h2 id="JavaBean和List结合存储"><a href="#JavaBean和List结合存储" class="headerlink" title="JavaBean和List结合存储"></a>JavaBean和List结合存储</h2><p>每一行数据使用JavaBean对象存储，多行使用放到Map或List中。代码如下：</p>
<pre><code class="java">package com.msl.collection;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * 测试表格数据的存储
 * 体会ORM思想
 * 每一行数据使用javabean对象存储，多行使用放到map或list中
 * @author Senley
 *
 */
public class TestStoreData2 &#123;
    public static void main(String[] args) &#123;
        User user1 = new User(1001,&quot;张三&quot;,20000,&quot;2018.5.5&quot;);
        User user2 = new User(1002,&quot;李四&quot;,30000,&quot;2005.5.4&quot;);
        User user3 = new User(1003,&quot;王五&quot;,3000,&quot;2020.5.4&quot;);
        
        List&lt;User&gt; list = new ArrayList&lt;&gt;();
        list.add(user1);
        list.add(user2);
        list.add(user3);
        for(User u:list) &#123;
            System.out.println(u);
        &#125;
        
        Map&lt;Integer,User&gt; map = new HashMap&lt;&gt;();
        map.put(1001, user1);
        map.put(1002, user2);
        map.put(1003, user3);
        Set&lt;Integer&gt; keyset = map.keySet();
        for(Integer key:keyset) &#123;
            System.out.println(key+&quot;====&quot;+map.get(key));
        &#125;
    &#125;
&#125;

class User&#123;
    private int id;
    private String name;
    private double salary;
    private String hiredate;
    
    //一个完整的javabean要有set和get方法以及一个无参构造器
    public User() &#123;
    &#125;
    
    public User(int id, String name, double salary, String hiredate) &#123;
        super();
        this.id = id;
        this.name = name;
        this.salary = salary;
        this.hiredate = hiredate;
    &#125;
    
    public int getId() &#123;
        return id;
    &#125;
    public void setId(int id) &#123;
        this.id = id;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public double getSalary() &#123;
        return salary;
    &#125;
    public void setSalary(double salary) &#123;
        this.salary = salary;
    &#125;
    public String getHiredate() &#123;
        return hiredate;
    &#125;
    public void setHiredate(String hiredate) &#123;
        this.hiredate = hiredate;
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;id:&quot;+id+&quot;,name:&quot;+name+&quot;,salary:&quot;+salary+&quot;,hiredate:&quot;+hiredate;
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">id:1001,name:张三,salary:20000.0,hiredate:2018.5.5
id:1002,name:李四,salary:30000.0,hiredate:2005.5.4
id:1003,name:王五,salary:3000.0,hiredate:2020.5.4
1001====id:1001,name:张三,salary:20000.0,hiredate:2018.5.5
1002====id:1002,name:李四,salary:30000.0,hiredate:2005.5.4
1003====id:1003,name:王五,salary:3000.0,hiredate:2020.5.4
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>StoreData</tag>
      </tags>
  </entry>
  <entry>
    <title>使用递归及面向对象思想统计文件夹大小</title>
    <url>/2021/11/26/%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%8F%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<h1 id="使用递归及面向对象思想统计文件夹大小"><a href="#使用递归及面向对象思想统计文件夹大小" class="headerlink" title="使用递归及面向对象思想统计文件夹大小"></a><strong>使用递归及面向对象思想统计文件夹大小</strong></h1><h2 id="IO介绍"><a href="#IO介绍" class="headerlink" title="IO介绍"></a>IO介绍</h2><p>对于任何程序设计语言而言，输入输出(Input/Output)系统都是非常核心的功能。程序运行需要数据，数据的获取往往需要跟外部系统进行通信，外部系统可能是文件、数据库、其他程序、网络、IO设备等等。外部系统比较复杂多变，那么就有必要通过某种手段进行抽象、屏蔽外部的差异，从而实现更加便捷的编程。</p>
<p>输入(Input)指的是：可以让程序从外部系统获得数据(核心含义是“读”，读取外部数据)。常见的应用：</p>
<ul>
<li>读取硬盘上的文件内容到程序。例如：播放器打开一个视频文件、word打开一个doc文件。</li>
<li>读取网络上某个位置内容到程序。例如：浏览器中输入网址后，打开该网址对应的网页内容；下载网络上某个网址的文件。</li>
<li>读取数据库系统的数据到程序。</li>
<li>读取某些硬件系统数据到程序。例如：车载电脑读取雷达扫描信息到程序；温控系统等。</li>
</ul>
<p>输出(Output)指的是：程序输出数据给外部系统从而可以操作外部系统(核心含义是“写”，将数据写出到外部系统)。常见的应用有：</p>
<ul>
<li>将数据写到硬盘中。例如：我们编辑完一个word文档后，将内容写到硬盘上进行保存。</li>
<li>将数据写到数据库系统中。例如：我们注册一个网站会员，实际就是后台程序向数据库中写入一条记录。</li>
<li>将数据写到某些硬件系统中。例如：导弹系统导航程序将新的路径输出到飞控子系统，飞控子系统根据数据修正飞行路径。</li>
</ul>
<h2 id="File类介绍"><a href="#File类介绍" class="headerlink" title="File类介绍"></a>File类介绍</h2><p>Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。</p>
<p>File对象代表磁盘中实际存在的文件和目录。通过以下构造方法创建一个File对象。</p>
<p>通过给定的父抽象路径名和子路径名字符串创建一个新的File实例。</p>
<pre><code class="java">File(File parent, String child);
</code></pre>
<p>通过将给定路径名字符串转换成抽象路径名来创建一个新 File 实例。</p>
<pre><code class="java">File(String pathname) 
</code></pre>
<p>根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。</p>
<pre><code class="java">File(String parent, String child) 
</code></pre>
<p>通过将给定的 file: URI 转换成一个抽象路径名来创建一个新的 File 实例。</p>
<pre><code class="java">File(URI uri) 
</code></pre>
<p>创建File对象成功后，可以使用以下列表中的方法操作文件。</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><strong>public String getName()</strong> 返回由此抽象路径名表示的文件或目录的名称。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">**public String getParent()**<strong>、</strong>  返回此抽象路径名的父路径名的路径名字符串，如果此路径名没有指定父目录，则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><strong>public File getParentFile()</strong> 返回此抽象路径名的父路径名的抽象路径名，如果此路径名没有指定父目录，则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><strong>public String getPath()</strong> 将此抽象路径名转换为一个路径名字符串。</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><strong>public boolean isAbsolute()</strong> 测试此抽象路径名是否为绝对路径名。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left"><strong>public String getAbsolutePath()</strong> 返回抽象路径名的绝对路径名字符串。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left"><strong>public boolean canRead()</strong> 测试应用程序是否可以读取此抽象路径名表示的文件。</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left"><strong>public boolean canWrite()</strong> 测试应用程序是否可以修改此抽象路径名表示的文件。</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left"><strong>public boolean exists()</strong> 测试此抽象路径名表示的文件或目录是否存在。</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left"><strong>public boolean isDirectory()</strong> 测试此抽象路径名表示的文件是否是一个目录。</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left"><strong>public boolean isFile()</strong> 测试此抽象路径名表示的文件是否是一个标准文件。</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left"><strong>public long lastModified()</strong> 返回此抽象路径名表示的文件最后一次被修改的时间。</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left"><strong>public long length()</strong> 返回由此抽象路径名表示的文件的长度。</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left"><strong>public boolean createNewFile() throws IOException</strong> 当且仅当不存在具有此抽象路径名指定的名称的文件时，原子地创建由此抽象路径名指定的一个新的空文件。</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left"><strong>public boolean delete()</strong>  删除此抽象路径名表示的文件或目录。</td>
</tr>
<tr>
<td align="center">16</td>
<td align="left"><strong>public void deleteOnExit()</strong> 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。</td>
</tr>
<tr>
<td align="center">17</td>
<td align="left"><strong>public String[] list()</strong> 返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。</td>
</tr>
<tr>
<td align="center">18</td>
<td align="left"><strong>public String[] list(FilenameFilter filter)</strong> 返回由包含在目录中的文件和目录的名称所组成的字符串数组，这一目录是通过满足指定过滤器的抽象路径名来表示的。</td>
</tr>
<tr>
<td align="center">19</td>
<td align="left"><strong>public File[] listFiles()</strong>  返回一个抽象路径名数组，这些路径名表示此抽象路径名所表示目录中的文件。</td>
</tr>
<tr>
<td align="center">20</td>
<td align="left"><strong>public File[] listFiles(FileFilter filter)</strong> 返回表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组，这些路径名满足特定过滤器。</td>
</tr>
<tr>
<td align="center">21</td>
<td align="left"><strong>public boolean mkdir()</strong> 创建此抽象路径名指定的目录。</td>
</tr>
<tr>
<td align="center">22</td>
<td align="left"><strong>public boolean mkdirs()</strong> 创建此抽象路径名指定的目录，包括创建必需但不存在的父目录。</td>
</tr>
<tr>
<td align="center">23</td>
<td align="left"><strong>public boolean renameTo(File dest)</strong>  重新命名此抽象路径名表示的文件。</td>
</tr>
<tr>
<td align="center">24</td>
<td align="left"><strong>public boolean setLastModified(long time)</strong> 设置由此抽象路径名所指定的文件或目录的最后一次修改时间。</td>
</tr>
<tr>
<td align="center">25</td>
<td align="left"><strong>public boolean setReadOnly()</strong> 标记此抽象路径名指定的文件或目录，以便只可对其进行读操作。</td>
</tr>
<tr>
<td align="center">26</td>
<td align="left"><strong>public static File createTempFile(String prefix, String suffix, File directory) throws IOException</strong> 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</td>
</tr>
<tr>
<td align="center">27</td>
<td align="left"><strong>public static File createTempFile(String prefix, String suffix) throws IOException</strong> 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。</td>
</tr>
<tr>
<td align="center">28</td>
<td align="left"><strong>public int compareTo(File pathname)</strong> 按字母顺序比较两个抽象路径名。</td>
</tr>
<tr>
<td align="center">29</td>
<td align="left"><strong>public int compareTo(Object o)</strong> 按字母顺序比较抽象路径名与给定对象。</td>
</tr>
<tr>
<td align="center">30</td>
<td align="left"><strong>public boolean equals(Object obj)</strong> 测试此抽象路径名与给定对象是否相等。</td>
</tr>
<tr>
<td align="center">31</td>
<td align="left"><strong>public String toString()</strong>  返回此抽象路径名的路径名字符串。</td>
</tr>
</tbody></table>
<h2 id="使用递归及面向对象思想统计文件夹大小、文件个数、文件夹个数"><a href="#使用递归及面向对象思想统计文件夹大小、文件个数、文件夹个数" class="headerlink" title="使用递归及面向对象思想统计文件夹大小、文件个数、文件夹个数"></a>使用递归及面向对象思想统计文件夹大小、文件个数、文件夹个数</h2><p>代码如下：</p>
<pre><code class="java">package com.msl.io;

import java.io.File;

/**
 * 使用递归及面向对象: 统计文件夹大小、文件个数、文件夹个数
 * @author Senley
 * 
 */
public class DirSize &#123;
    //大小
    private long len;
    //文件夹路径
    private String path;
    //文件个数
    private int fileCount;
    //文件夹个数
    private int dirCount;
    //源
    private File src;
    
    public long getLen() &#123;
        return len;
    &#125;
    
    public int getFileCount() &#123;
        return fileCount;
    &#125;

    public int getDirCount() &#123;
        return dirCount;
    &#125;
    
    public DirSize(String path) &#123;
        this.path = path;
        this.src = new File(path);
        count(src);
    &#125;

    public static void main(String[] args) &#123;
        DirSize dir = new DirSize(&quot;E:/Workspace/IO&quot;);
        System.out.println(&quot;文件夹大小：&quot;+dir.getLen()+&quot;字节&quot;+ &quot;--&quot;+&quot;文件个数：&quot;+dir.getFileCount()+&quot; --&quot;+&quot;文件夹个数：&quot;+dir.getDirCount());
    &#125;
    
    //统计大小
    private void count(File src)&#123;
        //获取大小
        if(null!=src &amp;&amp; src.exists()) &#123;
            if(src.isFile()) &#123;//大小
                fileCount++;
                len+=src.length();
            &#125;else&#123;//子孙级
                dirCount++;
                for(File s:src.listFiles()) &#123;
                    count(s);
                &#125;
            &#125;
        &#125;
    &#125;

&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">文件夹大小：60850字节 --文件个数：29 --文件夹个数：13
</code></pre>
<p>需注意的是，文件夹个数为子孙级文件夹个数+本身，如需仅显示子孙级文件夹，可定义dirCount = -1。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程可重入锁的原理实现</title>
    <url>/2022/02/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="多线程可重入锁的原理实现"><a href="#多线程可重入锁的原理实现" class="headerlink" title="多线程可重入锁的原理实现"></a>多线程可重入锁的原理实现</h1><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>锁作为并发共享数据保证一致性的工具，大多数内置锁都是可重入的，也就是说，如果某个线程试图获取一个已经由它自己持有的锁时，那么这个请求会立刻成功，并且会将这个锁的计数值加1，而当线程退出同步代码块时，计数器将会递减，当计数值等于0时，锁释放。如果没有可重入锁的支持，在第二次企图获得锁时将会进入死锁状态。</p>
<p>可重入锁随处可见，如synchronized 和ReentrantLock。</p>
<h2 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a><strong>原理实现</strong></h2><p>手动实现一个可重入锁，代码如下：</p>
<pre><code class="java">package com.msl.others;

import java.util.concurrent.locks.ReentrantLock;

/**
 * 可重入锁: 锁可以延续使用 + 计数器
 * 
 * @author Senley
 *
 */
public class LockTest &#123;
    ReentrantLock lock = new ReentrantLock();
    public void a() throws InterruptedException &#123;
        lock.lock();
        System.out.println(lock.getHoldCount());
        doSomething();
        lock.unlock();
        System.out.println(lock.getHoldCount());
    &#125;
    //不可重入
    public void doSomething() throws InterruptedException &#123;
        lock.lock();
        System.out.println(lock.getHoldCount());
        //...................
        lock.unlock();
        System.out.println(lock.getHoldCount());
    &#125;
    public static void main(String[] args) throws InterruptedException &#123;
        LockTest04 test = new LockTest04();
        test.a();            
        Thread.sleep(1000);        
        System.out.println(test.lock.getHoldCount());
    &#125;

&#125;
</code></pre>
<p>结果如下:</p>
<pre><code class="java">1
2
1
0
0
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程synchronized实现简单的影院购票功能</title>
    <url>/2022/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BD%B1%E9%99%A2%E8%B4%AD%E7%A5%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="多线程synchronized实现简单的影院购票功能"><a href="#多线程synchronized实现简单的影院购票功能" class="headerlink" title="多线程synchronized实现简单的影院购票功能"></a>多线程synchronized实现简单的影院购票功能</h1><p>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突的问题。解决该问题的机制是synchronized关键字，它包括两种用法：synchronized 方法和 synchronized 块。</p>
<h2 id="synchronized-方法"><a href="#synchronized-方法" class="headerlink" title="synchronized 方法"></a><strong>synchronized 方法</strong></h2><p> 通过在方法声明中加入 synchronized关键字来声明，语法如下：</p>
<pre><code class="java">public synchronized void accessVal(int newVal);
</code></pre>
<p>synchronized 方法控制对“对象的类成员变量”的访问：每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。</p>
<h2 id="synchronized-块"><a href="#synchronized-块" class="headerlink" title="synchronized 块"></a><strong>synchronized 块</strong></h2><p>synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率。</p>
<p>Java 为我们提供了更好的解决办法，那就是 synchronized 块。 块可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率。</p>
<p>synchronized 块：通过 synchronized关键字来声明synchronized 块，语法如下：</p>
<pre><code class="java">synchronized(syncObject)
　  &#123; 
　　 //允许访问控制的代码 
　  &#125;
</code></pre>
<h2 id="实现简单的影院购票功能"><a href="#实现简单的影院购票功能" class="headerlink" title="实现简单的影院购票功能"></a>实现简单的影院购票功能</h2><p>代码如下：</p>
<pre><code class="java">package com.msl.syn;

import java.util.ArrayList;
import java.util.List;

/**
 * 实现简单的影院购票功能 - 快乐影院
 * @author Senley
 *
 */
public class HappyCinema2 &#123;
    public static void main(String[] args) &#123;
        //可用位置
        List&lt;Integer&gt; available = new ArrayList&lt;Integer&gt;();
        available.add(1);
        available.add(2);
        available.add(5);
        available.add(6);
        available.add(7);
        //顾客需要的位置
        List&lt;Integer&gt; seats1 = new ArrayList&lt;Integer&gt;();
        seats1.add(1);
        seats1.add(2);
        List&lt;Integer&gt; seats2 = new ArrayList&lt;Integer&gt;();
        seats2.add(3);
        seats2.add(6);
        
        MslCinema m = new MslCinema(available, &quot;Happy Cinema&quot;);
        new Thread(new HappyCustomer(m, seats1),&quot;张三&quot;).start();
        new Thread(new HappyCustomer(m, seats2),&quot;李四&quot;).start();
    &#125;
    
&#125;

//影院
class MslCinema&#123;
    List&lt;Integer&gt; available; //可用的位置
    String name; //名称
    
    public MslCinema(List&lt;Integer&gt; available, String name) &#123;
        this.available = available;
        this.name = name;
    &#125;
    
    //购票
    public boolean bookTickets(List&lt;Integer&gt; seats) &#123;
        System.out.println(&quot;欢迎光临&quot;+this.name+&quot;，可用位置为：&quot;+available);
        List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;();
        copy.addAll(available);
        //相减
        copy.removeAll(seats);
        //判断大小
        if(available.size()-seats.size()!=copy.size()) &#123;
            return false;
        &#125;
        //成功
        available = copy;
        return true;
    &#125;
&#125;

//顾客
class HappyCustomer implements Runnable&#123;
    MslCinema cinema;
    List&lt;Integer&gt; seats;

    public HappyCustomer(MslCinema cinema, List&lt;Integer&gt; seats) &#123;
        super();
        this.cinema = cinema;
        this.seats = seats;
    &#125;

    @Override
    public void run() &#123;
        synchronized(cinema) &#123;
            boolean flag = cinema.bookTickets(seats);
            if(flag) &#123;
                System.out.println(&quot;出票成功--&quot;+Thread.currentThread().getName()+&quot;--位置为&quot;+seats);
            &#125;else &#123;
                System.out.println(&quot;出票失败--&quot;+Thread.currentThread().getName()+&quot;--位置不够&quot;);        
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">欢迎光临Happy Cinema，可用位置为：[1, 2, 5, 6, 7]
出票成功--张三--位置为[1, 2]
欢迎光临Happy Cinema，可用位置为：[5, 6, 7]
出票失败--李四--位置不够
</code></pre>
<p>“synchronized (cinema)” 意味着线程需要获得cinema对象的“锁”才有资格运行同步块中的代码。cinema对象的“锁”也称为“互斥锁”，在同一时刻只能被一个线程使用。A线程拥有锁，则可以调用“同步块”中的代码；B线程没有锁，则进入cinema对象的“锁池队列”等待，直到A线程使用完毕释放了cinema对象的锁，B线程得到锁才可以开始调用“同步块”中的代码。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发协作模型-生产者消费者模式</title>
    <url>/2022/02/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%9E%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="多线程并发协作模型-生产者消费者模式"><a href="#多线程并发协作模型-生产者消费者模式" class="headerlink" title="多线程并发协作模型-生产者消费者模式"></a>多线程并发协作模型-生产者消费者模式</h1><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul>
<li><p>假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。</p>
</li>
<li><p>如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。</p>
</li>
<li><p>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。</p>
<p><img src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/Producer-consumer-problem.png" alt="Producer-consumer-problem"></p>
</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。</p>
<ul>
<li><p>对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费。</p>
</li>
<li><p>对于消费者，在消费之后，要通知生产者已经消费结束，需要继续生产新产品以供消费。</p>
</li>
<li><p>在生产者消费者问题中，仅有synchronized是不够的。</p>
<ul>
<li>synchronized可阻止并发更新同一个共享资源，实现了同步。</li>
<li>synchronized不能用来实现不同线程之间的消息传递（通信）。</li>
</ul>
</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ul>
<li>并发协作模型-生产者消费者模式—&gt;管程法</li>
<li>并发协作模型-生产者消费者模式—&gt;信号灯法</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a><strong>管程法</strong></h4><p>示例代码如下：</p>
<pre><code class="java">package com.msl.cooperation;
/**
 * 协作模型:生产者消费者实现方式一:管程法
 * 借助缓冲区
 * 
 * @author Senley
 *
 */
public class CoTest01 &#123;
    public static void main(String[] args) &#123;
        SynContainer container = new SynContainer();
        new Productor(container).start();
        new Consumer(container).start();
    &#125;
&#125;
//生产者
class Productor extends Thread&#123;
    SynContainer container  ;    
    public Productor(SynContainer container) &#123;
        this.container = container;
    &#125;

    public void run() &#123;
        //生产
        for(int i=0;i&lt;100;i++) &#123;
            System.out.println(&quot;生产--&gt;&quot;+i+&quot;个馒头&quot;);
            container.push(new Steamedbun(i) );
        &#125;
    &#125;
&#125;
//消费者
class Consumer extends Thread&#123;
    SynContainer container  ;    
    public Consumer(SynContainer container) &#123;
        this.container = container;
    &#125;
    public void run() &#123;
        //消费
        for(int i=0;i&lt;100;i++) &#123;
            System.out.println(&quot;消费--&gt;&quot;+container.pop().id+&quot;个馒头&quot;);
        &#125;
    &#125;
&#125;
//缓冲区
class SynContainer&#123;
    Steamedbun[] buns = new Steamedbun[10]; //存储容器
    int count = 0; //计数器
    //存储 生产
    public synchronized void push(Steamedbun bun) &#123;
        //何时能生产  容器存在空间
        //不能生产 只有等待
        if(count == buns.length) &#123;
            try &#123;
                this.wait(); //线程阻塞  消费者通知生产解除
            &#125; catch (InterruptedException e) &#123;
            &#125;
        &#125;
        //存在空间 可以生产
        buns[count] = bun;
        count++;
        //存在数据了，可以通知消费了
        this.notifyAll();
    &#125;
    //获取 消费
    public synchronized Steamedbun pop() &#123;
        //何时消费 容器中是否存在数据
        //没有数据 只有等待
        if(count == 0) &#123;
            try &#123;
                this.wait(); //线程阻塞  生产者通知消费解除
            &#125; catch (InterruptedException e) &#123;
            &#125;
        &#125;
        //存在数据可以消费
        count --;
        Steamedbun bun = buns[count] ;        
        this.notifyAll(); //存在空间了，可以唤醒对方生产了
        return bun;
    &#125;
&#125;
//馒头
class Steamedbun&#123;
    int id;
    public Steamedbun(int id) &#123;
        this.id = id;
    &#125;
    
&#125;
</code></pre>
<p>结果如下:</p>
<pre><code class="java">生产--&gt;0个馒头
生产--&gt;1个馒头
生产--&gt;2个馒头
生产--&gt;3个馒头
生产--&gt;4个馒头
生产--&gt;5个馒头
生产--&gt;6个馒头
生产--&gt;7个馒头
生产--&gt;8个馒头
生产--&gt;9个馒头
生产--&gt;10个馒头
生产--&gt;11个馒头
消费--&gt;9个馒头
消费--&gt;10个馒头
消费--&gt;11个馒头
消费--&gt;8个馒头
生产--&gt;12个馒头
生产--&gt;13个馒头
消费--&gt;7个馒头
生产--&gt;14个馒头
消费--&gt;13个馒头
生产--&gt;15个馒头
消费--&gt;14个馒头
生产--&gt;16个馒头
消费--&gt;15个馒头
生产--&gt;17个馒头
消费--&gt;16个馒头
生产--&gt;18个馒头
消费--&gt;17个馒头
生产--&gt;19个馒头
生产--&gt;20个馒头
生产--&gt;21个馒头
消费--&gt;18个馒头
消费--&gt;20个馒头
生产--&gt;22个馒头
消费--&gt;21个馒头
消费--&gt;22个馒头
生产--&gt;23个馒头
消费--&gt;19个馒头
生产--&gt;24个馒头
消费--&gt;23个馒头
生产--&gt;25个馒头
消费--&gt;24个馒头
生产--&gt;26个馒头
生产--&gt;27个馒头
生产--&gt;28个馒头
消费--&gt;25个馒头
消费--&gt;27个馒头
生产--&gt;29个馒头
生产--&gt;30个馒头
消费--&gt;28个馒头
消费--&gt;29个馒头
生产--&gt;31个馒头
生产--&gt;32个馒头
消费--&gt;30个馒头
消费--&gt;31个馒头
生产--&gt;33个馒头
生产--&gt;34个馒头
消费--&gt;32个馒头
消费--&gt;33个馒头
生产--&gt;35个馒头
生产--&gt;36个馒头
消费--&gt;34个馒头
消费--&gt;35个馒头
生产--&gt;37个馒头
消费--&gt;36个馒头
生产--&gt;38个馒头
消费--&gt;37个馒头
生产--&gt;39个馒头
消费--&gt;38个馒头
生产--&gt;40个馒头
消费--&gt;39个馒头
生产--&gt;41个馒头
消费--&gt;40个馒头
生产--&gt;42个馒头
消费--&gt;41个馒头
消费--&gt;42个馒头
消费--&gt;26个馒头
消费--&gt;12个馒头
生产--&gt;43个馒头
消费--&gt;6个馒头
消费--&gt;43个馒头
消费--&gt;5个馒头
消费--&gt;4个馒头
消费--&gt;3个馒头
消费--&gt;2个馒头
消费--&gt;1个馒头
消费--&gt;0个馒头
生产--&gt;44个馒头
生产--&gt;45个馒头
消费--&gt;44个馒头
生产--&gt;46个馒头
消费--&gt;45个馒头
生产--&gt;47个馒头
消费--&gt;46个馒头
生产--&gt;48个馒头
消费--&gt;47个馒头
生产--&gt;49个馒头
消费--&gt;48个馒头
生产--&gt;50个馒头
消费--&gt;49个馒头
生产--&gt;51个馒头
消费--&gt;50个馒头
生产--&gt;52个馒头
消费--&gt;51个馒头
生产--&gt;53个馒头
消费--&gt;52个馒头
生产--&gt;54个馒头
消费--&gt;53个馒头
消费--&gt;54个馒头
生产--&gt;55个馒头
生产--&gt;56个馒头
消费--&gt;55个馒头
生产--&gt;57个馒头
消费--&gt;56个馒头
生产--&gt;58个馒头
消费--&gt;57个馒头
生产--&gt;59个馒头
消费--&gt;58个馒头
生产--&gt;60个馒头
消费--&gt;59个馒头
生产--&gt;61个馒头
消费--&gt;60个馒头
生产--&gt;62个馒头
消费--&gt;61个馒头
生产--&gt;63个馒头
消费--&gt;62个馒头
生产--&gt;64个馒头
消费--&gt;63个馒头
消费--&gt;64个馒头
生产--&gt;65个馒头
生产--&gt;66个馒头
消费--&gt;65个馒头
生产--&gt;67个馒头
消费--&gt;66个馒头
生产--&gt;68个馒头
消费--&gt;67个馒头
生产--&gt;69个馒头
消费--&gt;68个馒头
消费--&gt;69个馒头
生产--&gt;70个馒头
生产--&gt;71个馒头
消费--&gt;70个馒头
生产--&gt;72个馒头
消费--&gt;71个馒头
消费--&gt;72个馒头
生产--&gt;73个馒头
生产--&gt;74个馒头
生产--&gt;75个馒头
生产--&gt;76个馒头
消费--&gt;73个馒头
消费--&gt;76个馒头
消费--&gt;75个馒头
消费--&gt;74个馒头
生产--&gt;77个馒头
生产--&gt;78个馒头
消费--&gt;77个馒头
消费--&gt;78个馒头
生产--&gt;79个馒头
消费--&gt;79个馒头
生产--&gt;80个馒头
生产--&gt;81个馒头
消费--&gt;80个馒头
消费--&gt;81个馒头
生产--&gt;82个馒头
生产--&gt;83个馒头
消费--&gt;82个馒头
消费--&gt;83个馒头
生产--&gt;84个馒头
生产--&gt;85个馒头
消费--&gt;84个馒头
消费--&gt;85个馒头
生产--&gt;86个馒头
生产--&gt;87个馒头
消费--&gt;86个馒头
生产--&gt;88个馒头
消费--&gt;87个馒头
生产--&gt;89个馒头
消费--&gt;88个馒头
消费--&gt;89个馒头
生产--&gt;90个馒头
生产--&gt;91个馒头
消费--&gt;90个馒头
消费--&gt;91个馒头
生产--&gt;92个馒头
生产--&gt;93个馒头
消费--&gt;92个馒头
生产--&gt;94个馒头
消费--&gt;93个馒头
生产--&gt;95个馒头
消费--&gt;94个馒头
消费--&gt;95个馒头
生产--&gt;96个馒头
生产--&gt;97个馒头
消费--&gt;96个馒头
消费--&gt;97个馒头
生产--&gt;98个馒头
生产--&gt;99个馒头
消费--&gt;98个馒头
消费--&gt;99个馒头
</code></pre>
<h4 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h4><p>示例代码如下：</p>
<pre><code class="java">package com.msl.cooperation;
/**
 * 协作模型:生产者消费者实现方式二:信号灯法
 * 借助标志位
 * 
 * @author Senley
 *
 */
public class CoTest02 &#123;
    public static void main(String[] args) &#123;
        Tv tv  =new Tv();
        new Player(tv).start();
        new Watcher(tv).start();
    &#125;
&#125;
//生产者 演员
class Player extends Thread&#123;
    Tv tv;    
    public Player(Tv tv) &#123;
        this.tv = tv;
    &#125;

    public void run() &#123;
        for(int i=0;i&lt;20;i++) &#123;
            if(i%2==0) &#123;
                this.tv.play(&quot;欢乐集结号&quot;);
            &#125;else &#123;
                this.tv.play(&quot;怕上火 喝加多宝&quot;);
            &#125;
        &#125;
    &#125;
&#125;
//消费者 观众
class Watcher extends Thread&#123;
    Tv tv;    
    public Watcher(Tv tv) &#123;
        this.tv = tv;
    &#125;

    public void run() &#123;
        for(int i=0;i&lt;20;i++) &#123;
            tv.watch();
        &#125;
    &#125;
&#125;
//同一个资源 电视
class Tv&#123;
    String voice;
    //信号灯
    //T 表示演员表演 观众等待
    //F 表示观众观看 演员等待
    boolean flag = true;
    
    //表演
    public  synchronized void play(String voice) &#123;
        //演员等待
        if(!flag) &#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;        
        //表演
        System.out.println(&quot;表演了:&quot;+voice);
        this.voice = voice;
        //唤醒
        this.notifyAll();
        //切换标志
        this.flag =!this.flag;
    &#125;
    //观看
    public synchronized  void watch() &#123;
        //观众等待
        if(flag) &#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        //观看
        System.out.println(&quot;听到了:&quot;+voice);
        //唤醒
        this.notifyAll();
        //切换标志
        this.flag =!this.flag;
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程的实现方式及简单模拟</title>
    <url>/2022/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1 id="多线程的实现方式及简单模拟"><a href="#多线程的实现方式及简单模拟" class="headerlink" title="多线程的实现方式及简单模拟"></a>多线程的实现方式及简单模拟</h1><h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><ol>
<li>继承Thread类<ul>
<li>1、创建：继承Thread + 重写run</li>
<li>2、启动：创建子类对象 + start</li>
</ul>
</li>
<li>Runnable接口（<strong>避免单继承的局限性，优先使用接口</strong>）<ul>
<li>1、创建：实现Runnable + 重写run</li>
<li>2、启动：创建实现类对象 + Thread对象 + start</li>
</ul>
</li>
<li>Callable接口<ul>
<li>1、创建目标对象</li>
<li>2、创建执行服务</li>
<li>3、提交执行</li>
<li>4、获取结果</li>
<li>5、关闭服务</li>
</ul>
</li>
</ol>
<h2 id="多线程的简单模拟"><a href="#多线程的简单模拟" class="headerlink" title="多线程的简单模拟"></a>多线程的简单模拟</h2><h3 id="模拟12306"><a href="#模拟12306" class="headerlink" title="模拟12306"></a>模拟12306</h3><p>代码如下：</p>
<pre><code class="java">package com.msl.thread;
/**
 * 模拟12306
 * @author Senley
 *
 */
public class Web12306 implements Runnable &#123;
    //票数
    private int ticketNums = 99;
    
    @Override
    public void run() &#123;
        while(true) &#123;
            if(ticketNums&lt;0) &#123;
                break;
            &#125;
            try &#123;
                Thread.sleep(200);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+ticketNums--);
        &#125;
    &#125;
    
    public static void main(String[] args) &#123;
        //一份资源
        Web12306 web = new Web12306();
        System.out.println(Thread.currentThread().getName());
        //多个代理
        new Thread(web,&quot;码畜&quot;).start();
        new Thread(web,&quot;码农&quot;).start();
        new Thread(web,&quot;码蟥&quot;).start();
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">main
码畜--&gt;99
码蟥--&gt;97
码农--&gt;98
码农--&gt;96
码蟥--&gt;96
码畜--&gt;96
码畜--&gt;95
码农--&gt;95
码蟥--&gt;95
码畜--&gt;94
码农--&gt;94
码蟥--&gt;93
码蟥--&gt;92
码农--&gt;91
码畜--&gt;90
码畜--&gt;89
码农--&gt;88
码蟥--&gt;88
码蟥--&gt;87
码畜--&gt;86
码农--&gt;85
码蟥--&gt;84
码农--&gt;84
码畜--&gt;83
码畜--&gt;82
码蟥--&gt;82
码农--&gt;82
码蟥--&gt;80
码农--&gt;81
码畜--&gt;81
码畜--&gt;79
码蟥--&gt;78
码农--&gt;79
码农--&gt;77
码畜--&gt;77
码蟥--&gt;77
码畜--&gt;76
码农--&gt;74
码蟥--&gt;75
码农--&gt;73
码蟥--&gt;72
码畜--&gt;73
码农--&gt;71
码畜--&gt;71
码蟥--&gt;70
码农--&gt;69
码蟥--&gt;68
码畜--&gt;69
码蟥--&gt;66
码农--&gt;67
码畜--&gt;65
码蟥--&gt;62
码农--&gt;63
码畜--&gt;64
码畜--&gt;61
码蟥--&gt;60
码农--&gt;59
码畜--&gt;58
码蟥--&gt;57
码农--&gt;58
码农--&gt;56
码畜--&gt;56
码蟥--&gt;56
码蟥--&gt;55
码农--&gt;55
码畜--&gt;54
码蟥--&gt;53
码农--&gt;51
码畜--&gt;52
码畜--&gt;50
码蟥--&gt;50
码农--&gt;50
码农--&gt;48
码蟥--&gt;49
码畜--&gt;47
码畜--&gt;44
码农--&gt;45
码蟥--&gt;46
码畜--&gt;43
码农--&gt;41
码蟥--&gt;42
码农--&gt;39
码畜--&gt;40
码蟥--&gt;40
码畜--&gt;38
码农--&gt;38
码蟥--&gt;38
码畜--&gt;37
码农--&gt;37
码蟥--&gt;37
码蟥--&gt;35
码农--&gt;35
码畜--&gt;36
码畜--&gt;34
码蟥--&gt;34
码农--&gt;34
码农--&gt;33
码畜--&gt;33
码蟥--&gt;33
码蟥--&gt;32
码农--&gt;32
码畜--&gt;32
码畜--&gt;31
码农--&gt;31
码蟥--&gt;31
码蟥--&gt;30
码畜--&gt;30
码农--&gt;30
码农--&gt;29
码蟥--&gt;28
码畜--&gt;29
码畜--&gt;27
码农--&gt;26
码蟥--&gt;27
码畜--&gt;25
码农--&gt;25
码蟥--&gt;25
码蟥--&gt;24
码农--&gt;23
码畜--&gt;23
码蟥--&gt;22
码农--&gt;22
码畜--&gt;22
码畜--&gt;21
码蟥--&gt;19
码农--&gt;20
码蟥--&gt;18
码畜--&gt;18
码农--&gt;17
码蟥--&gt;16
码农--&gt;15
码畜--&gt;14
码畜--&gt;13
码农--&gt;13
码蟥--&gt;13
码蟥--&gt;12
码农--&gt;11
码畜--&gt;12
码农--&gt;10
码畜--&gt;9
码蟥--&gt;8
码农--&gt;7
码畜--&gt;6
码蟥--&gt;7
码畜--&gt;5
码农--&gt;3
码蟥--&gt;4
码蟥--&gt;2
码农--&gt;2
码畜--&gt;2
码畜--&gt;0
码农--&gt;1
码蟥--&gt;1
</code></pre>
<h3 id="模拟龟兔赛跑"><a href="#模拟龟兔赛跑" class="headerlink" title="模拟龟兔赛跑"></a>模拟龟兔赛跑</h3><p>代码如下：</p>
<pre><code class="java">package com.msl.thread;
/**
 * 模拟龟兔赛跑
 * @author Senley
 *
 */
public class Racer implements Runnable&#123;
    private String winner;//胜利者
    @Override
    public void run() &#123;
        for(int steps=1;steps&lt;=100;steps++) &#123;
            //模拟休息
            if(Thread.currentThread().getName().equals(&quot;rabbit&quot;)&amp;&amp;steps%10==0) &#123;
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+steps);
            //比赛是否结束
            boolean flag = gameOver(steps);
            if(flag) &#123;
                break;
            &#125;
        &#125;
    &#125;
    
    private boolean gameOver(int steps) &#123;
        if(winner!=null) &#123;//存在胜利者
            return true;
        &#125;else &#123;
            if(steps==100) &#123;
                winner = Thread.currentThread().getName();
                System.out.println(&quot;winner--&gt;&quot;+winner);
                return true;
            &#125;
        &#125;
        return false;
    &#125;
    
    public static void main(String[] args) &#123;
        Racer racer = new Racer();
        new Thread(racer,&quot;tortoise&quot;).start();
        new Thread(racer,&quot;rabbit&quot;).start();
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">tortoise--&gt;1
rabbit--&gt;1
rabbit--&gt;2
rabbit--&gt;3
rabbit--&gt;4
rabbit--&gt;5
rabbit--&gt;6
rabbit--&gt;7
rabbit--&gt;8
rabbit--&gt;9
tortoise--&gt;2
tortoise--&gt;3
tortoise--&gt;4
tortoise--&gt;5
tortoise--&gt;6
tortoise--&gt;7
tortoise--&gt;8
tortoise--&gt;9
tortoise--&gt;10
tortoise--&gt;11
tortoise--&gt;12
tortoise--&gt;13
tortoise--&gt;14
tortoise--&gt;15
tortoise--&gt;16
tortoise--&gt;17
tortoise--&gt;18
tortoise--&gt;19
tortoise--&gt;20
tortoise--&gt;21
tortoise--&gt;22
tortoise--&gt;23
tortoise--&gt;24
tortoise--&gt;25
tortoise--&gt;26
tortoise--&gt;27
tortoise--&gt;28
tortoise--&gt;29
tortoise--&gt;30
tortoise--&gt;31
tortoise--&gt;32
tortoise--&gt;33
tortoise--&gt;34
tortoise--&gt;35
tortoise--&gt;36
tortoise--&gt;37
tortoise--&gt;38
tortoise--&gt;39
tortoise--&gt;40
tortoise--&gt;41
tortoise--&gt;42
tortoise--&gt;43
tortoise--&gt;44
tortoise--&gt;45
tortoise--&gt;46
tortoise--&gt;47
tortoise--&gt;48
tortoise--&gt;49
tortoise--&gt;50
tortoise--&gt;51
tortoise--&gt;52
tortoise--&gt;53
tortoise--&gt;54
tortoise--&gt;55
tortoise--&gt;56
tortoise--&gt;57
tortoise--&gt;58
tortoise--&gt;59
tortoise--&gt;60
tortoise--&gt;61
tortoise--&gt;62
tortoise--&gt;63
tortoise--&gt;64
tortoise--&gt;65
tortoise--&gt;66
tortoise--&gt;67
tortoise--&gt;68
tortoise--&gt;69
tortoise--&gt;70
tortoise--&gt;71
tortoise--&gt;72
tortoise--&gt;73
tortoise--&gt;74
tortoise--&gt;75
tortoise--&gt;76
tortoise--&gt;77
tortoise--&gt;78
tortoise--&gt;79
tortoise--&gt;80
tortoise--&gt;81
tortoise--&gt;82
tortoise--&gt;83
tortoise--&gt;84
tortoise--&gt;85
tortoise--&gt;86
tortoise--&gt;87
tortoise--&gt;88
tortoise--&gt;89
tortoise--&gt;90
tortoise--&gt;91
tortoise--&gt;92
tortoise--&gt;93
tortoise--&gt;94
tortoise--&gt;95
tortoise--&gt;96
tortoise--&gt;97
tortoise--&gt;98
tortoise--&gt;99
tortoise--&gt;100
winner--&gt;tortoise
rabbit--&gt;10
</code></pre>
<h3 id="模拟龟兔赛跑（使用Callable）"><a href="#模拟龟兔赛跑（使用Callable）" class="headerlink" title="模拟龟兔赛跑（使用Callable）"></a>模拟龟兔赛跑（使用Callable）</h3><p>代码如下：</p>
<pre><code class="java">package com.msl.thread;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * 模拟龟兔赛跑
 * @author Senley
 *
 */
public class CRacer implements Callable&lt;Integer&gt;&#123;
    private String winner;//胜利者
    @Override
    public Integer call() throws Exception &#123;
        for(int steps=1;steps&lt;=100;steps++) &#123;
            //模拟休息
            if(Thread.currentThread().getName().equals(&quot;pool-1-thread-1&quot;)&amp;&amp;steps%10==0) &#123;
                Thread.sleep(100);
            &#125;
            System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+steps);
            //比赛是否结束
            boolean flag = gameOver(steps);
            if(flag) &#123;
                return steps;
            &#125;
        &#125;
        return null;
    &#125;
    
    private boolean gameOver(int steps) &#123;
        if(winner!=null) &#123;//存在胜利者
            return true;
        &#125;else &#123;
            if(steps==100) &#123;
                winner = Thread.currentThread().getName();
                System.out.println(&quot;winner--&gt;&quot;+winner);
                return true;
            &#125;
        &#125;
        return false;
    &#125;
    
    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;
        CRacer racer = new CRacer();
        //创建执行服务: 
        ExecutorService  ser=Executors.newFixedThreadPool(2);
        //提交执行: 
        Future&lt;Integer&gt; result1 =ser.submit(racer) ;
        Future&lt;Integer&gt; result2 =ser.submit(racer) ;
        //获取结果:  
        Integer r1 =result1.get();
        Integer r2 =result2.get();
        System.out.println(r1+&quot;--&gt;&quot;+r2);
        //关闭服务:  
        ser.shutdownNow();
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">pool-1-thread-2--&gt;1
pool-1-thread-1--&gt;1
pool-1-thread-1--&gt;2
pool-1-thread-1--&gt;3
pool-1-thread-1--&gt;4
pool-1-thread-1--&gt;5
pool-1-thread-1--&gt;6
pool-1-thread-1--&gt;7
pool-1-thread-1--&gt;8
pool-1-thread-1--&gt;9
pool-1-thread-2--&gt;2
pool-1-thread-2--&gt;3
pool-1-thread-2--&gt;4
pool-1-thread-2--&gt;5
pool-1-thread-2--&gt;6
pool-1-thread-2--&gt;7
pool-1-thread-2--&gt;8
pool-1-thread-2--&gt;9
pool-1-thread-2--&gt;10
pool-1-thread-2--&gt;11
pool-1-thread-2--&gt;12
pool-1-thread-2--&gt;13
pool-1-thread-2--&gt;14
pool-1-thread-2--&gt;15
pool-1-thread-2--&gt;16
pool-1-thread-2--&gt;17
pool-1-thread-2--&gt;18
pool-1-thread-2--&gt;19
pool-1-thread-2--&gt;20
pool-1-thread-2--&gt;21
pool-1-thread-2--&gt;22
pool-1-thread-2--&gt;23
pool-1-thread-2--&gt;24
pool-1-thread-2--&gt;25
pool-1-thread-2--&gt;26
pool-1-thread-2--&gt;27
pool-1-thread-2--&gt;28
pool-1-thread-2--&gt;29
pool-1-thread-2--&gt;30
pool-1-thread-2--&gt;31
pool-1-thread-2--&gt;32
pool-1-thread-2--&gt;33
pool-1-thread-2--&gt;34
pool-1-thread-2--&gt;35
pool-1-thread-2--&gt;36
pool-1-thread-2--&gt;37
pool-1-thread-2--&gt;38
pool-1-thread-2--&gt;39
pool-1-thread-2--&gt;40
pool-1-thread-2--&gt;41
pool-1-thread-2--&gt;42
pool-1-thread-2--&gt;43
pool-1-thread-2--&gt;44
pool-1-thread-2--&gt;45
pool-1-thread-2--&gt;46
pool-1-thread-2--&gt;47
pool-1-thread-2--&gt;48
pool-1-thread-2--&gt;49
pool-1-thread-2--&gt;50
pool-1-thread-2--&gt;51
pool-1-thread-2--&gt;52
pool-1-thread-2--&gt;53
pool-1-thread-2--&gt;54
pool-1-thread-2--&gt;55
pool-1-thread-2--&gt;56
pool-1-thread-2--&gt;57
pool-1-thread-2--&gt;58
pool-1-thread-2--&gt;59
pool-1-thread-2--&gt;60
pool-1-thread-2--&gt;61
pool-1-thread-2--&gt;62
pool-1-thread-2--&gt;63
pool-1-thread-2--&gt;64
pool-1-thread-2--&gt;65
pool-1-thread-2--&gt;66
pool-1-thread-2--&gt;67
pool-1-thread-2--&gt;68
pool-1-thread-2--&gt;69
pool-1-thread-2--&gt;70
pool-1-thread-2--&gt;71
pool-1-thread-2--&gt;72
pool-1-thread-2--&gt;73
pool-1-thread-2--&gt;74
pool-1-thread-2--&gt;75
pool-1-thread-2--&gt;76
pool-1-thread-2--&gt;77
pool-1-thread-2--&gt;78
pool-1-thread-2--&gt;79
pool-1-thread-2--&gt;80
pool-1-thread-2--&gt;81
pool-1-thread-2--&gt;82
pool-1-thread-2--&gt;83
pool-1-thread-2--&gt;84
pool-1-thread-2--&gt;85
pool-1-thread-2--&gt;86
pool-1-thread-2--&gt;87
pool-1-thread-2--&gt;88
pool-1-thread-2--&gt;89
pool-1-thread-2--&gt;90
pool-1-thread-2--&gt;91
pool-1-thread-2--&gt;92
pool-1-thread-2--&gt;93
pool-1-thread-2--&gt;94
pool-1-thread-2--&gt;95
pool-1-thread-2--&gt;96
pool-1-thread-2--&gt;97
pool-1-thread-2--&gt;98
pool-1-thread-2--&gt;99
pool-1-thread-2--&gt;100
winner--&gt;pool-1-thread-2
pool-1-thread-1--&gt;10
10--&gt;100
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义一个ArrayList</title>
    <url>/2021/11/07/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAArrayList/</url>
    <content><![CDATA[<h1 id="自定义一个ArrayList"><a href="#自定义一个ArrayList" class="headerlink" title="自定义一个ArrayList"></a>自定义一个ArrayList</h1><h2 id="ArrayList特点和底层实现"><a href="#ArrayList特点和底层实现" class="headerlink" title="ArrayList特点和底层实现"></a>ArrayList特点和底层实现</h2><p>ArrayList底层是用数组实现的存储。 特点：查询效率高，增删效率低，线程不安全。查看源码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/202111071028176.png" alt="自定义一个ArrayList1"></p>
<p>可以看出ArrayList底层使用Object数组来存储元素数据。所有的方法，都围绕这个核心的Object数组来开展。</p>
<p>我们知道，数组长度是有限的，而ArrayList是可以存放任意数量的对象，长度不受限制，那么它是怎么实现的呢?本质上就是通过定义新的更大的数组，将旧数组中的内容拷贝到新数组，来实现扩容。 ArrayList的Object数组初始化长度为10，如果我们存储满了这个数组，需要存储第11个对象，就会定义新的长度更大的数组，并将原数组内容和新的元素一起加入到新数组中，源码如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/202111071030809.png" alt="自定义一个ArrayList2"></p>
<h2 id="自定义一个ArrayList，体会底层原理"><a href="#自定义一个ArrayList，体会底层原理" class="headerlink" title="自定义一个ArrayList，体会底层原理"></a>自定义一个ArrayList，体会底层原理</h2><p>代码如下：</p>
<pre><code class="java">package com.msl.mycollection;

import javax.management.RuntimeErrorException;

/**
 * 自定义实现一个ArrayList,体会底层原理
 * @author Senley
 *
 */
public class MslArrayList&lt;E&gt; &#123;
    
    private Object[] elementData;
    private int size;
    private static final int DEFALT_CAPACITY = 10;
    
    public MslArrayList() &#123;
        elementData = new Object[DEFALT_CAPACITY];
    &#125;
    
    public MslArrayList(int capacity) &#123;
        if(capacity&lt;0) &#123;
            throw new RuntimeException(&quot;容器的容量不能为负数&quot;);
        &#125;else if(capacity==0) &#123;
            elementData = new Object[DEFALT_CAPACITY];
        &#125;else &#123;
            elementData = new Object[capacity];
        &#125;
    &#125;
    
    public int size() &#123;
        return size;
    &#125;
    
    public boolean isEmpty() &#123;
        return size==0?true:false;
    &#125;
    
    public void add(E element) &#123;
        //什么时候扩容
        if(size == elementData.length) &#123;
            //扩容操作
            Object[] newArray = new Object[elementData.length + (elementData.length&gt;&gt;1)];//10--&gt;10+10/2
            System.arraycopy(elementData, 0, newArray, 0, elementData.length);
            elementData = newArray;        
        &#125;
        elementData[size++] = element;
    &#125;
    
    public E get(int index) &#123;
        checkRange(index);
        return (E) elementData[index];
    &#125;
    
    public void set(E element,int index) &#123;
        checkRange(index);
        elementData[index] = element;
    &#125;
    
    public void checkRange(int index) &#123;
        //索引合法判断[0,size)
        if(index&lt;0 || index&gt;size-1) &#123;
            //不合法
            throw new RuntimeException(&quot;索引不合法:&quot;+index);
        &#125;
    &#125;
    
    public void remove(E element) &#123;
        //将element和所有元素挨个比较,获得第一个比较为true的,返回.
        for(int i=0;i&lt;size;i++) &#123;
            if(element.equals(get(i))) &#123;//容器中所有的比较操作都是用的equals而不是==
                //将该元素从此处移除
                remove(i);
            &#125;
        &#125;
    &#125;
    
    public void remove(int index) &#123;
        int numMoved = elementData.length-index-1;
        if(numMoved&gt;0) &#123;
            System.arraycopy(elementData, index+1, elementData, index, elementData.length-index-1);
        &#125;
        elementData[--size] = null;
    &#125;
    
    @Override
    public String toString() &#123;
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;[&quot;);
        for(int i=0;i&lt;size;i++) &#123;
            sb.append(elementData[i]+&quot;,&quot;);
        &#125;
        sb.setCharAt(sb.length()-1, &#39;]&#39;);
        return sb.toString();
    &#125;
    
    public static void main(String[] args) &#123;
        MslArrayList m = new MslArrayList(20);
        for(int i=0;i&lt;40;i++) &#123;
            m.add(&quot;senley&quot;+i);
        &#125;
        System.out.println(m);
        m.set(&quot;test&quot;, 10);
        System.out.println(m.get(10));
        m.remove(3);
        System.out.println(m);
        m.remove(&quot;test&quot;);
        System.out.println(m);
        System.out.println(m.size);
        System.out.println(m.isEmpty());
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">[senley0,senley1,senley2,senley3,senley4,senley5,senley6,senley7,senley8,senley9,senley10,senley11,senley12,senley13,senley14,senley15,senley16,senley17,senley18,senley19,senley20,senley21,senley22,senley23,senley24,senley25,senley26,senley27,senley28,senley29,senley30,senley31,senley32,senley33,senley34,senley35,senley36,senley37,senley38,senley39]
test
[senley0,senley1,senley2,senley4,senley5,senley6,senley7,senley8,senley9,test,senley11,senley12,senley13,senley14,senley15,senley16,senley17,senley18,senley19,senley20,senley21,senley22,senley23,senley24,senley25,senley26,senley27,senley28,senley29,senley30,senley31,senley32,senley33,senley34,senley35,senley36,senley37,senley38,senley39]
[senley0,senley1,senley2,senley4,senley5,senley6,senley7,senley8,senley9,senley11,senley12,senley13,senley14,senley15,senley16,senley17,senley18,senley19,senley20,senley21,senley22,senley23,senley24,senley25,senley26,senley27,senley28,senley29,senley30,senley31,senley32,senley33,senley34,senley35,senley36,senley37,senley38,senley39]
38
false
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义一个HashSet</title>
    <url>/2021/11/18/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAHashSet/</url>
    <content><![CDATA[<h1 id="自定义一个HashSet"><a href="#自定义一个HashSet" class="headerlink" title="自定义一个HashSet"></a>自定义一个HashSet</h1><h2 id="HashSet特点和底层实现"><a href="#HashSet特点和底层实现" class="headerlink" title="HashSet特点和底层实现"></a>HashSet特点和底层实现</h2><ul>
<li><p>HashSet底层是HashMap；</p>
</li>
<li><p>向Hashset中添加元素, 实际上是把这个元素作为键添加到底层的HashMap中；</p>
</li>
<li><p>HashSet实际上就是底层HashMap的键的集合。</p>
</li>
</ul>
<p> HashSet是采用哈希算法实现，底层实际是用HashMap实现的(HashSet本质就是一个简化版的HashMap)，因此，查询效率和增删效率都比较高。查看HashSet的源码：</p>
<pre><code class="java">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123;
    static final long serialVersionUID = -5024744406713321676L;

    private transient HashMap&lt;E,Object&gt; map;

    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();

    /**
     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has
     * default initial capacity (16) and load factor (0.75).
     */
    public HashSet() &#123;
        map = new HashMap&lt;&gt;();
    &#125;
    
     /**
     * Adds the specified element to this set if it is not already present.
     * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if
     * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that
     * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.
     * If this set already contains the element, the call leaves the set
     * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.
     *
     * @param e element to be added to this set
     * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified
     * element
     */
    public boolean add(E e) &#123;
        return map.put(e, PRESENT)==null;
    &#125;
    //以下代码省略
&#125;
</code></pre>
<p>可以发现里面有个map属性，这就是HashSet的核心秘密。再看add()方法，可以发现增加一个元素，说白了就是在map中增加一个键值对，键对象就是这个元素，值对象是名为PRESENT的Object对象。说白了就是“往set中加入元素，本质就是把这个元素作为key加入到了内部的map中”。</p>
<p>由于map中key都是不可重复的，因此，Set天然具有“不可重复”的特性。</p>
<h2 id="自定义一个HashSet，体会底层原理"><a href="#自定义一个HashSet，体会底层原理" class="headerlink" title="自定义一个HashSet，体会底层原理"></a>自定义一个HashSet，体会底层原理</h2><p>代码如下：</p>
<pre><code class="java">package com.msl.mycollection;

import java.util.HashMap;

/**
 * 手动实现一个HashSet，深刻理解HashSet底层原理
 * @author Senley
 *
 */
public class MslHashSet &#123;
    HashMap map;
    private static final Object PRESENT = new Object();
    
    public static void main(String[] args) &#123;
        MslHashSet set = new MslHashSet();
        set.add(&quot;aaa&quot;);
        set.add(&quot;bbb&quot;);
        set.add(&quot;ccc&quot;);
        System.out.println(set);
    &#125;
    
    public MslHashSet()&#123;
        map = new HashMap();
    &#125;
    
    public int size() &#123;
        return map.size();
    &#125;
    
    public void add(Object o) &#123;
        map.put(o, PRESENT);
    &#125;
    
    @Override
    public String toString() &#123;
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;[&quot;);
        for(Object key:map.keySet()) &#123;
            sb.append(key+&quot;,&quot;);
        &#125;
        sb.setCharAt(sb.length()-1, &#39;]&#39;);
        return sb.toString();
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">[aaa,ccc,bbb]
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义一个HashMap</title>
    <url>/2021/11/14/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAHashMap/</url>
    <content><![CDATA[<h1 id="自定义一个HashMap"><a href="#自定义一个HashMap" class="headerlink" title="自定义一个HashMap"></a>自定义一个HashMap</h1><h2 id="HashMap的结构"><a href="#HashMap的结构" class="headerlink" title="HashMap的结构"></a>HashMap的结构</h2><p>在HashMap底层实现原理中，聊过Node&lt;K,V&gt;[]数组的结构，也是HashMap的结构。如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/Node%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="Node数组存储结构"></p>
<h2 id="自定义一个Node类"><a href="#自定义一个Node类" class="headerlink" title="自定义一个Node类"></a>自定义一个Node类</h2><pre><code class="java">package com.msl.mycollection;
/**
 * 用于MslHashMap中
 * @author Senley
 *
 */
public class Node&lt;K,V&gt; &#123;
    int hash;
    K key;
    V value;
    Node next;
&#125;
</code></pre>
<h2 id="自定义一个HashMap，体会底层原理"><a href="#自定义一个HashMap，体会底层原理" class="headerlink" title="自定义一个HashMap，体会底层原理"></a>自定义一个HashMap，体会底层原理</h2><p>在上述基础上自定义实现一个HashMap，实现如下简单功能：</p>
<ol>
<li>实现put方法增加键值对；</li>
<li>解决键重复问题和链表生成问题；</li>
<li>实现toString方法，方便查看Map中的键值对信息；</li>
<li>实现get方法，根据键对象获得对应的值对象；</li>
<li>增加泛型。</li>
</ol>
<p>代码如下：</p>
<pre><code class="java">package com.msl.mycollection;
/**
 * 自定义一个HashMap
 * @author Senley
 *
 */
public class MslHashMap&lt;K,V&gt; &#123;
    Node[] table;  //位桶数组。bucket array
    int size;      //存放的键值对的个数
    
    public static void main(String[] args) &#123;
        MslHashMap&lt;Integer,String&gt; m = new MslHashMap&lt;&gt;();
        m.put(10, &quot;aa&quot;);
        m.put(20, &quot;bb&quot;);
        m.put(30, &quot;cc&quot;);
        m.put(20, &quot;ss&quot;);
        
        m.put(53, &quot;ee&quot;);
        m.put(69, &quot;ff&quot;);
        m.put(85, &quot;gg&quot;);
        
        System.out.println(m);
        
//        for(int i=10;i&lt;100;i++) &#123;
//            System.out.println(i+&quot;---&quot;+myHash(i,16)); //53,69,85
//        &#125;
        
        System.out.println(m.get(53));
    &#125;
    
    public MslHashMap() &#123;
        table = new Node[16]; //长度一般定义成2的整数幂
    &#125;
    
    @Override
    public String toString() &#123;
        //&#123;10:aa,20:bb&#125;
        StringBuilder sb = new StringBuilder(&quot;&#123;&quot;);
        //遍历bucket数组
        for(int i=0;i&lt;table.length;i++) &#123;
            Node temp = table[i];
            //遍历链表
            while(temp!=null) &#123;
                sb.append(temp.key+&quot;:&quot;+temp.value+&quot;,&quot;);
                temp = temp.next;
            &#125;
        &#125;
        sb.setCharAt(sb.length()-1, &#39;&#125;&#39;);
        return sb.toString();
    &#125;
    
    public void put(K key,V value) &#123;
        //还需要考虑数组扩容问题！
        
        //定义了新的结点对象
        Node newNode = new Node();
        newNode.hash = myHash(key.hashCode(),table.length);
        newNode.key = key;
        newNode.value = value;
        newNode.next = null;
        
        Node temp = table[newNode.hash];
        Node iterLast = null; //正在遍历的最后一个元素
        boolean keyRepeat = false; 
        if(temp == null) &#123;
            //此处数组元素为空，则直接将新结点放进去
            table[newNode.hash] = newNode;
            size++;
        &#125;else &#123;
            //此处数组元素不为空，则遍历对应链表
            while(temp!=null) &#123;
                //判断key如果重复，则覆盖
                if(temp.key.equals(key)) &#123;
                    keyRepeat = true;
                    System.out.println(&quot;key重复了&quot;);
                    temp.value = value; //只是覆盖value即可，其他的值（hash,key,next）保持不变
                    break;
                &#125;else &#123;
                    //key不重复，则遍历下一个
                    iterLast = temp;
                    temp = temp.next;
                &#125;
            &#125;
            if(!keyRepeat) &#123; //如果没有发生key重复的情况，则添加到链表最后
                iterLast.next = newNode;
                size++;
            &#125;
        &#125;
    &#125;
    
    public V get(K key) &#123;
        int hash = myHash(key.hashCode(),table.length);
        V value = null;
        if(table[hash]!=null) &#123;
            Node temp = table[hash];
            while(temp!=null) &#123;
                if(temp.key.equals(key)) &#123; //如果相等则说明找对了键值对，返回相应的value
                    value = (V) temp.value;
                    break;
                &#125;else &#123;
                    temp = temp.next;
                &#125;
            &#125;
        &#125;
        return value;
    &#125;
    
    public static int myHash(int v,int length) &#123;
//        System.out.println(&quot;hash in myHash:&quot;+(v&amp;(length-1))); //直接位运算，效率高
//        System.out.println(&quot;hash in myHash:&quot;+(v%(length-1))); //取模运算，效率低
        return v&amp;(length-1);
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">key重复了
&#123;20:ss,53:ee,69:ff,85:gg,10:aa,30:cc&#125;
ee
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义一个LinkedList</title>
    <url>/2021/11/08/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AALinkedList/</url>
    <content><![CDATA[<h1 id="自定义一个LinkedList"><a href="#自定义一个LinkedList" class="headerlink" title="自定义一个LinkedList"></a>自定义一个LinkedList</h1><h2 id="LinkedList特点和底层实现"><a href="#LinkedList特点和底层实现" class="headerlink" title="LinkedList特点和底层实现"></a>LinkedList特点和底层实现</h2><p>LinkedList底层用双向链表实现的存储。特点：查询效率低，增删效率高，线程不安全。</p>
<p>双向链表也叫双链表，是链表的一种，它的每个数据节点中都有两个指针，分别指向前一个节点和后一个节点。 所以，从双向链表中的任意一个节点开始，都可以很方便地找到所有节点。下图为LinkedList的存储结构图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A81.png" alt="自定义一个链表1"></p>
<p>每个节点都应该有3部分内容：</p>
<pre><code class="java">class  Node &#123;
        Node  previous;     //前一个节点
        Object  element;    //本节点保存的数据
        Node  next;         //后一个节点
&#125;
</code></pre>
<p>查看LinkedList的源码，可以看到里面包含了双向链表的相关代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A82.png" alt="自定义一个链表2"></p>
<h2 id="自定义一个LinkedList，体会底层原理"><a href="#自定义一个LinkedList，体会底层原理" class="headerlink" title="自定义一个LinkedList，体会底层原理"></a>自定义一个LinkedList，体会底层原理</h2><p>代码如下：</p>
<pre><code class="java">package com.msl.mycollection;
/**
 * 自定义实现一个链表
 * @author Senley
 */
public class MslLinkedList&lt;E&gt; &#123;
    
    private Node first;
    private Node last;
    private int size;
    
    public static void main(String[] args) &#123;
        MslLinkedList&lt;String&gt; list = new MslLinkedList();
        list.add(&quot;a&quot;);
        list.add(&quot;b&quot;);
        list.add(&quot;c&quot;);
        System.out.println(list);
        System.out.println(list.get(2));
        list.remove(0);
        System.out.println(list);
        list.add(1, &quot;插入&quot;);
        System.out.println(list);
    &#125;
    
    public void add(int index,E element) &#123;
        checkRange(index);
        Node newNode = new Node(element);
        Node temp = getNode(index);
        if(temp!=null) &#123;
            Node up = temp.previous;
            up.next = newNode;
            newNode.previous = up;
            newNode.next = temp;
            temp.previous = newNode;
        &#125;
    &#125;
    
    public void remove(int index) &#123;
        checkRange(index);
        Node temp = getNode(index);
        if(temp!=null) &#123;
            Node up = temp.previous;
            Node down = temp.next;
            if(up!=null) &#123;
                up.next = down;
            &#125;
            if(down!=null) &#123;
                down.previous = up;
            &#125;
            //被删除的元素是第一个元素时
            if(index==0) &#123;
                first = down;
            &#125;
            //被删除的元素是最后一个元素时
            if(index==size-1) &#123;
                last = up;
            &#125;
            size--;
        &#125;
    &#125;
    
    public void add(E element) &#123;
        Node node = new Node(element);
        if(first==null) &#123;
//            node.previous = null;
//            node.next = null;
            first = node;
            last = node;
        &#125;else &#123;
            node.previous = last;
            node.next = null;
            last.next = node;
            last = node;
        &#125;
        size++;
    &#125;
    
    public E get(int index) &#123;
        checkRange(index);
        Node temp = getNode(index);
        return temp!=null?(E)temp.element:null;
    &#125;
    
    private void checkRange(int index) &#123;
        if(index&lt;0 || index&gt;size-1) &#123;
            throw new RuntimeException(&quot;索引数字不合法:&quot;+index);
        &#125;
    &#125;
    
    private Node getNode(int index) &#123;
        checkRange(index);
        Node temp = null;
        if(index&lt;=(size&gt;&gt;1)) &#123;//size&gt;&gt;1相当于除以2
            temp = first;
            for(int i=0;i&lt;index;i++) &#123;
                temp = temp.next;
            &#125;
        &#125;else &#123;
            temp = last;
            for(int i=size-1;i&gt;index;i--) &#123;
                temp = temp.previous;
            &#125;
        &#125; 
        return temp;
    &#125;
    
    @Override
    public String toString() &#123;
        //[a b c] first = a, last = c
        StringBuilder sb = new StringBuilder(&quot;[&quot;);
        Node temp = first;
        while(temp!=null) &#123;
            sb.append(temp.element+&quot;,&quot;);
            temp = temp.next;
        &#125;
        sb.setCharAt(sb.length()-1, &#39;]&#39;);
        return sb.toString();
    &#125;
    
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">[a,b,c]
c
[b,c]
[b,插入,c]
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器设计模式的理解与实现</title>
    <url>/2022/01/14/%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="装饰器设计模式的理解与实现"><a href="#装饰器设计模式的理解与实现" class="headerlink" title="装饰器设计模式的理解与实现"></a><strong>装饰器设计模式</strong>的理解与实现</h1><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<h2 id="装饰器设计模式的定义与特点"><a href="#装饰器设计模式的定义与特点" class="headerlink" title="装饰器设计模式的定义与特点"></a>装饰器设计模式的定义与特点</h2><p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰（Decorator）模式的主要优点有：</p>
<ul>
<li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态地给一个对象扩展功能，即插即用。</li>
<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果。</li>
<li>装饰器模式完全遵守开闭原则。</li>
</ul>
<p>其主要缺点是：</p>
<p>装饰模式会增加许多子类，过度使用会增加程序复杂性。</p>
<h2 id="装饰器设计模式的结构与实现"><a href="#装饰器设计模式的结构与实现" class="headerlink" title="装饰器设计模式的结构与实现"></a>装饰器设计模式的结构与实现</h2><h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><ul>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<h3 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h3><p>代码如下：</p>
<pre><code class="java">package com.msl.io;
/**
 * 模拟咖啡
 * 1、抽象组件:需要装饰的抽象对象(接口或抽象父类)
 * 2、具体组件:需要装饰的对象
 * 3、抽象装饰类:包含了对抽象组件的引用以及装饰者共有的方法
 * 4、具体装饰类:被装饰的对象
 * @author Senley
 *
 */
public class DecorateTest &#123;
    public static void main(String[] args) &#123;
        Drink coffer = new Coffer();
        Drink suger = new Suger(coffer);//装饰
        System.out.println(suger.info()+&quot;--&gt;&quot;+suger.cost());
        Drink milk = new Milk(coffer);//装饰
        System.out.println(milk.info()+&quot;--&gt;&quot;+milk.cost());
        milk = new Milk(suger);//装饰
        System.out.println(milk.info()+&quot;--&gt;&quot;+milk.cost());
    &#125;
&#125;

//抽象组件
interface Drink&#123;
    double cost();//费用
    String info();//说明
&#125;

//具体组件
class Coffer implements Drink&#123;
    private String name =&quot;原味咖啡&quot;;
    @Override
    public double cost() &#123;
        return 10;
    &#125;

    @Override
    public String info() &#123;
        return name;
    &#125;
&#125;

//抽象装饰类
abstract class Decorate implements Drink&#123;
    //对抽象组件的引用
    private Drink drink;
    public Decorate(Drink drink) &#123;
        this.drink = drink;
    &#125;
    @Override
    public double cost() &#123;
        return this.drink.cost();
    &#125;

    @Override
    public String info() &#123;
        return this.drink.info();
    &#125;
&#125;

//具体装饰类
class Milk extends Decorate&#123;
    public Milk(Drink drink) &#123;
        super(drink);
    &#125;
    @Override
    public double cost() &#123;
        return super.cost()*4;
    &#125;

    @Override
    public String info() &#123;
        return super.info()+&quot;加入了牛奶&quot;;
    &#125;
&#125;

class Suger extends Decorate&#123;
    public Suger(Drink drink) &#123;
        super(drink);
    &#125;
    @Override
    public double cost() &#123;
        return super.cost()*2;
    &#125;

    @Override
    public String info() &#123;
        return super.info()+&quot;加入了蔗糖&quot;;
    &#125;    
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">原味咖啡加入了蔗糖--&gt;20.0
原味咖啡加入了牛奶--&gt;40.0
原味咖啡加入了蔗糖加入了牛奶--&gt;80.0
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历集合的方法总结</title>
    <url>/2021/11/21/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="遍历集合-容器-的方法总结"><a href="#遍历集合-容器-的方法总结" class="headerlink" title="遍历集合(容器)的方法总结"></a><strong>遍历集合(容器)的方法总结</strong></h1><h2 id="使用Iterator迭代器遍历容器元素"><a href="#使用Iterator迭代器遍历容器元素" class="headerlink" title="使用Iterator迭代器遍历容器元素"></a>使用Iterator迭代器遍历容器元素</h2><h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><p>Java集合框架的集合类，我们有时候称之为容器。容器的种类有很多种，如ArrayList、LinkedList、HashSet…，每种容器都有自己的特点，ArrayList底层维护的是一个数组；LinkedList是链表结构；HashSet依赖的是哈希表，每种容器都有自己特有的数据结构。</p>
<p>因为容器的内部结构不同，很多时候可能不知道该怎样去遍历一个容器中的元素。所以为了使对容器内元素的操作更为简单，Java引入了迭代器模式。</p>
<p><strong>把访问逻辑从不同类型的集合类中抽取出来，从而避免向外部暴露集合的内部结构。</strong></p>
<p>使用Iterator遍历List、Set、Map，代码如下：</p>
<pre><code class="java">package com.msl.collection;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * 测试迭代器遍历集合
 * @author Senley
 *
 */
public class TestIterator &#123;
    public static void main(String[] args) &#123;
        testIteratorList();
        testIteratorSet();
        testIteratorMap();
    &#125;
    
    public static void testIteratorList() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;aa&quot;);
        list.add(&quot;bb&quot;);
        list.add(&quot;cc&quot;);
        
        //使用Iterator遍历List
        for(Iterator&lt;String&gt; iter=list.iterator();iter.hasNext();) &#123;
            String temp = iter.next();
            System.out.println(temp);
        &#125;
    &#125;
    
    public static void testIteratorSet() &#123;
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        set.add(&quot;aa&quot;);
        set.add(&quot;bb&quot;);
        set.add(&quot;cc&quot;);
        
        //使用Iterator遍历Set
        for(Iterator&lt;String&gt; iter=set.iterator();iter.hasNext();) &#123;
            String temp = iter.next();
            System.out.println(temp);
        &#125;
    &#125;
    
    public static void testIteratorMap() &#123;
        Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;();
        map.put(100,&quot;aa&quot;);
        map.put(200,&quot;bb&quot;);
        map.put(300,&quot;cc&quot;);
        
        //使用Iterator遍历Map，第一种方式
        Set&lt;Entry&lt;Integer,String&gt;&gt; ss = map.entrySet();
        for(Iterator&lt;Entry&lt;Integer,String&gt;&gt; iter=ss.iterator();iter.hasNext();) &#123;
            Entry&lt;Integer,String&gt; temp = iter.next();
            System.out.println(temp.getKey()+&quot;---&quot;+temp.getValue());
        &#125;
        
        //使用Iterator遍历Map，第二种方式
        Set&lt;Integer&gt; keySet = map.keySet();
        for(Iterator&lt;Integer&gt; iter=keySet.iterator();iter.hasNext();) &#123;
            Integer key = iter.next();
            System.out.println(key+&quot;---&quot;+map.get(key));
        &#125;
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">aa
bb
cc
aa
bb
cc
100---aa
200---bb
300---cc
100---aa
200---bb
300---cc
</code></pre>
<h2 id="遍历集合-容器-的方法"><a href="#遍历集合-容器-的方法" class="headerlink" title="遍历集合(容器)的方法"></a>遍历集合(容器)的方法</h2><h3 id="遍历List方法一：普通for循环"><a href="#遍历List方法一：普通for循环" class="headerlink" title="遍历List方法一：普通for循环"></a>遍历List方法一：普通for循环</h3><pre><code class="java">for(int i=0;i&lt;list.size();i++)&#123;//list为集合的对象名
    String temp = (String)list.get(i);
    System.out.println(temp);
&#125;
</code></pre>
<h3 id="遍历List方法二：增强for循环"><a href="#遍历List方法二：增强for循环" class="headerlink" title="遍历List方法二：增强for循环"></a>遍历List方法二：增强for循环</h3><pre><code class="java">for (String temp : list) &#123;
    System.out.println(temp);
&#125;
</code></pre>
<h3 id="遍历List方法三：使用Iterator迭代器-1"><a href="#遍历List方法三：使用Iterator迭代器-1" class="headerlink" title="遍历List方法三：使用Iterator迭代器(1)"></a>遍历List方法三：使用Iterator迭代器(1)</h3><pre><code class="java">for(Iterator iter = list.iterator();iter.hasNext();)&#123;
    String temp = (String)iter.next();
    System.out.println(temp);
&#125;
</code></pre>
<h3 id="遍历List方法四：使用Iterator迭代器-2"><a href="#遍历List方法四：使用Iterator迭代器-2" class="headerlink" title="遍历List方法四：使用Iterator迭代器(2)"></a>遍历List方法四：使用Iterator迭代器(2)</h3><pre><code class="java">Iterator iter = list.iterator();
while(iter.hasNext())&#123;
    Object  obj = iter.next();
    iter.remove();//如果要遍历时，删除集合中的元素，建议使用这种方式
    System.out.println(obj);
&#125;
</code></pre>
<h3 id="遍历Set方法一：增强for循环"><a href="#遍历Set方法一：增强for循环" class="headerlink" title="遍历Set方法一：增强for循环"></a>遍历Set方法一：增强for循环</h3><pre><code class="java">for(String temp:set)&#123;
    System.out.println(temp);
&#125;
</code></pre>
<h3 id="遍历Set方法二：使用Iterator迭代器"><a href="#遍历Set方法二：使用Iterator迭代器" class="headerlink" title="遍历Set方法二：使用Iterator迭代器"></a>遍历Set方法二：使用Iterator迭代器</h3><pre><code class="java">for(Iterator iter = set.iterator();iter.hasNext();)&#123;
    String temp = (String)iter.next();
    System.out.println(temp);
&#125;
</code></pre>
<h3 id="遍历Map方法一：根据key获取value"><a href="#遍历Map方法一：根据key获取value" class="headerlink" title="遍历Map方法一：根据key获取value"></a>遍历Map方法一：根据key获取value</h3><pre><code class="java">Map&lt;Integer, Man&gt; maps = new HashMap&lt;Integer, Man&gt;();
Set&lt;Integer&gt; keySet = maps.keySet();
for(Integer id : keySet)&#123;
    System.out.println(maps.get(id).name);
&#125;
</code></pre>
<h3 id="遍历Map方法二：使用entrySet"><a href="#遍历Map方法二：使用entrySet" class="headerlink" title="遍历Map方法二：使用entrySet"></a>遍历Map方法二：使用entrySet</h3><pre><code class="java">Set&lt;Entry&lt;Integer, Man&gt;&gt; ss = maps.entrySet();
for (Iterator iterator = ss.iterator(); iterator.hasNext();) &#123;
    Entry e = (Entry) iterator.next(); 
    System.out.println(e.getKey()+&quot;--&quot;+e.getValue());
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>基于TCP实现多用户登录</title>
    <url>/2022/03/02/%E5%9F%BA%E4%BA%8ETCP%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="基于TCP实现多用户登录"><a href="#基于TCP实现多用户登录" class="headerlink" title="基于TCP实现多用户登录"></a>基于TCP实现多用户登录</h1><ul>
<li><strong>创建服务器</strong></li>
</ul>
<ol>
<li>指定端口 使用ServerSocket创建服务器</li>
<li>阻塞式等待连接 accept</li>
<li>操作: 输入输出流操作</li>
<li>释放资源 </li>
</ol>
<ul>
<li><strong>创建客户端</strong></li>
</ul>
<ol>
<li>建立连接: 使用Socket创建客户端 +服务的地址和端口</li>
<li>操作: 输入输出流操作</li>
<li>释放资源 </li>
</ol>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a><strong>Server</strong></h2><pre><code class="java">package com.msl.tcp;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * 模拟登录 多个客户端请求
 * 创建服务器
 * 1、指定端口 使用ServerSocket创建服务器
 * 2、阻塞式等待连接 accept
 * 3、操作: 输入输出流操作
 * 4、释放资源 
 * @author Senley
 *
 */
public class LoginMultiServer &#123;
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;-----Server-----&quot;);
        // 1、指定端口 使用ServerSocket创建服务器
        ServerSocket server =new ServerSocket(8888);
        boolean isRunning =true;;
        // 2、阻塞式等待连接 accept
        while(isRunning) &#123;
            Socket  client =server.accept(); 
            System.out.println(&quot;一个客户端建立了连接&quot;);
            new Thread(new Channel(client)).start();
        &#125;
        server.close();
    &#125;
    //一个channel就代表一个客户端
    static class Channel implements Runnable&#123;
        private Socket client;
        //输入流
        private DataInputStream dis;
        //输出流
        private DataOutputStream dos;
        public Channel(Socket  client) &#123;
            this.client = client;
            try &#123;
                //输入
                dis = new DataInputStream(client.getInputStream());
                //输出
                dos =new DataOutputStream(client.getOutputStream());    
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
                release();
            &#125;
        &#125;
        
        //接收数据
        private String receive() &#123;
            String datas =&quot;&quot;;
            try &#123;
                datas = dis.readUTF();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            return datas;
        &#125;
        //释放资源
        private void release() &#123;
            // 4、释放资源 
            try &#123;
                if(null != dos) &#123;
                    dos.close();                    
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(null != dis) &#123;
                    dis.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(null != client) &#123;
                    client.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        //发送数据
        private void send(String msg) &#123;
            try &#123;
                dos.writeUTF(msg);
                dos.flush();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        @Override
        public void run() &#123;                        
            // 3、操作: 输入输出流操作                    
            String uname =&quot;&quot;;
            String upwd =&quot;&quot;;
            //分析
            String[] dataArray = receive().split(&quot;&amp;&quot;);
            for(String info:dataArray) &#123;
                    String[] userInfo =info.split(&quot;=&quot;);
                    if(userInfo[0].equals(&quot;uname&quot;)) &#123;
                        System.out.println(&quot;你的用户名为:&quot;+userInfo[1]);
                        uname = userInfo[1];
                    &#125;else if(userInfo[0].equals(&quot;upwd&quot;)) &#123;
                        System.out.println(&quot;你的密码为:&quot;+userInfo[1]);
                        upwd = userInfo[1];
                    &#125;                
            &#125;                    
            if(uname.equals(&quot;senley&quot;) &amp;&amp; upwd.equals(&quot;123&quot;)) &#123; //成功
                send(&quot;登录成功，欢迎回来&quot;);
            &#125;else &#123; //失败
                send(&quot;用户名或密码错误&quot;);
            &#125;        
            release();        
        &#125;    
    &#125;
&#125;
</code></pre>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><pre><code class="java">package com.msl.tcp;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.UnknownHostException;

/**
 * 模拟登录  多个客户端请求
 * 创建客户端
 * 1、建立连接: 使用Socket创建客户端 +服务的地址和端口
 * 2、操作: 输入输出流操作
 * 3、释放资源 
 * @author Senley
 *
 */
public class LoginMultiClient &#123;
    public static void main(String[] args) throws UnknownHostException, IOException &#123;        
        System.out.println(&quot;-----Client-----&quot;);
        //1、建立连接: 使用Socket创建客户端 +服务的地址和端口
        Socket client =new Socket(&quot;localhost&quot;,8888);
        //2、操作: 输入输出流操作  先请求后响应
        new Send(client).send();
        new Receive(client).receive();        
        client.close();
    &#125;
    //发送
    static class Send&#123;
        private Socket client;
        private DataOutputStream dos;
        private BufferedReader console ;
        private String msg;
        public Send(Socket client) &#123;            
            console=new BufferedReader(new InputStreamReader(System.in));
            this.msg =init();
            this.client = client;
            try &#123;
                dos=new DataOutputStream(client.getOutputStream());
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        private String init() &#123;                    
            try &#123;
                System.out.print(&quot;请输入用户名:&quot;);
                String uname =console.readLine();
                System.out.print(&quot;请输入密码:&quot;);
                String upwd =console.readLine();
                return &quot;uname=&quot;+uname+&quot;&amp;&quot;+&quot;upwd=&quot;+upwd;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            return &quot;&quot;;            
        &#125;
        
        public void send() &#123;
            try &#123;
                dos.writeUTF(msg);
                dos.flush();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
    //接收
    static class Receive&#123;
        private Socket client;
        private DataInputStream dis;
        public Receive(Socket client) &#123;
            this.client = client;
            try &#123;
                dis=new DataInputStream(client.getInputStream());
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;        
        public void receive() &#123;
            String result;
            try &#123;
                result = dis.readUTF();
                System.out.println(result);
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;        
        &#125;
    &#125;
&#125;
</code></pre>
<p>示例结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/LoginMultiServer.png" alt="LoginMultiServer"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Net</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2022/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h1><h2 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h2><p>单例模式属于创建类型的一种常用的软件设计模式，可以保证一个类只有一个实例并提供一个访问该实例的全局访问点。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><ul>
<li>Windows的Task Manager（任务管理器）就是很典型的单例模式。</li>
<li>Windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。</li>
<li>网站的计数器，一般也是采用单例模式实现，否则难以同步。</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
<li>操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。</li>
<li>Application 也是单例的典型应用（Servlet编程中会涉及到）。</li>
<li>Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理。</li>
<li>Servlet编程中，每个Servlet也是单例。</li>
<li>SpringMVC框架/Struts1框架中，控制器对象也是单例。</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</li>
<li>单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</li>
</ul>
<h2 id="常见的五种单例模式实现方式"><a href="#常见的五种单例模式实现方式" class="headerlink" title="常见的五种单例模式实现方式"></a><strong>常见的五种单例模式实现方式</strong></h2><ul>
<li>主要：<ul>
<li><strong>饿汉式</strong>（线程安全，调用效率高。 但是，不能延时加载。）</li>
<li><strong>懒汉式</strong>（线程安全，调用效率不高。 但是，可以延时加载。）</li>
</ul>
</li>
<li>其他：<ul>
<li><strong>双重检测锁式</strong>（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）</li>
<li><strong>静态内部类式</strong>（线程安全，调用效率高。 但是，可以延时加载）</li>
<li><strong>枚举式</strong>（线程安全，调用效率高，不能延时加载）</li>
</ul>
</li>
</ul>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>示例代码如下：</p>
<pre><code class="java">package com.msl.singleton;
/**
 * 测试饿汉式单例模式
 * @author Senley
 *
 */
public class SingletonDemo1 &#123;
    
    //类初始化时，立即加载这个对象（没有延时加载的优势）。加载类时，天然的是线程安全的！
    private static SingletonDemo1 instance = new SingletonDemo1();
    
    private SingletonDemo1() &#123;
    &#125;
    
    //方法没有同步，调用效率高！
    public static SingletonDemo1 getInstance() &#123;
        return instance;
    &#125;
    
&#125;
</code></pre>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>示例代码如下：</p>
<pre><code class="java">package com.msl.singleton;

/**
 * 测试懒汉式单例模式
 * @author Senley
 *
 */
public class SingletonDemo2 &#123;
    
    //类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。
    private static SingletonDemo2 instance;  
    
    private SingletonDemo2()&#123; //私有化构造器
    &#125;
    
    //方法同步，调用效率低！
    public static  synchronized SingletonDemo2  getInstance()&#123;
        if(instance==null)&#123;
            instance = new SingletonDemo2();
        &#125;
        return instance;
    &#125;
    
&#125;
</code></pre>
<h4 id="双重检测锁式"><a href="#双重检测锁式" class="headerlink" title="双重检测锁式"></a>双重检测锁式</h4><p>示例代码如下：</p>
<pre><code class="java">package com.msl.singleton;

/**
 * 双重检查锁实现单例模式
 * @author Senley
 *
 */
public class SingletonDemo3 &#123; 

  private static SingletonDemo3 instance = null; 

  public static SingletonDemo3 getInstance() &#123; 
    if (instance == null) &#123; 
      SingletonDemo3 sc; 
      synchronized (SingletonDemo3.class) &#123; 
        sc = instance; 
        if (sc == null) &#123; 
          synchronized (SingletonDemo3.class) &#123; 
            if(sc == null) &#123; 
              sc = new SingletonDemo3(); 
            &#125; 
          &#125; 
          instance = sc; 
        &#125; 
      &#125; 
    &#125; 
    return instance; 
  &#125; 

  private SingletonDemo3() &#123; 

  &#125; 
    
&#125;
</code></pre>
<h4 id="静态内部类式"><a href="#静态内部类式" class="headerlink" title="静态内部类式"></a>静态内部类式</h4><p>示例代码如下：</p>
<pre><code class="java">package com.msl.singleton;

/**
 * 测试静态内部类实现单例模式
 * 这种方式：线程安全，调用效率高，并且实现了延时加载！
 * @author Senley
 *
 */
public class SingletonDemo4 &#123;
    
    private static class SingletonClassInstance &#123;
        private static final SingletonDemo4 instance = new SingletonDemo4();
    &#125;
    
    private SingletonDemo4()&#123;
    &#125;
    
    //方法没有同步，调用效率高！
    public static SingletonDemo4  getInstance()&#123;
        return SingletonClassInstance.instance;
    &#125;
    
&#125;
</code></pre>
<h4 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h4><p>示例代码如下：</p>
<pre><code class="java">package com.msl.singleton;

/**
 * 测试枚举式实现单例模式(没有延时加载)
 * @author Senley
 *
 */
public enum SingletonDemo5 &#123;
    
    //这个枚举元素，本身就是单例对象！
    INSTANCE;
    
    //添加自己需要的操作！
    public void singletonOperation()&#123;
    &#125;
    
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Pattern</tag>
      </tags>
  </entry>
</search>
