<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> senleima</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- Highlight.js -->
      <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.3.1/styles/github-dark.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="senleima" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/senleima"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">senleima</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['欢迎来到Senley的博客', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-多线程可重入锁的原理实现"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/02/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2022-02-27T16:27:06.125Z" itemprop="datePublished">2022-02-28</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>title: 多线程可重入锁的原理实现<br>date: 2022-02-28 00:14:01<br>categories: Java基础<br>tags: Thread</p>
<h1 id="多线程可重入锁的原理实现"><a href="#多线程可重入锁的原理实现" class="headerlink" title="多线程可重入锁的原理实现"></a>多线程可重入锁的原理实现</h1><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>锁作为并发共享数据保证一致性的工具，大多数内置锁都是可重入的，也就是说，如果某个线程试图获取一个已经由它自己持有的锁时，那么这个请求会立刻成功，并且会将这个锁的计数值加1，而当线程退出同步代码块时，计数器将会递减，当计数值等于0时，锁释放。如果没有可重入锁的支持，在第二次企图获得锁时将会进入死锁状态。</p>
<p>可重入锁随处可见，如synchronized 和ReentrantLock。</p>
<h2 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a><strong>原理实现</strong></h2><p>手动实现一个可重入锁，代码如下：</p>
<pre><code class="java">package com.msl.others;

import java.util.concurrent.locks.ReentrantLock;

/**
 * 可重入锁: 锁可以延续使用 + 计数器
 * 
 * @author Senley
 *
 */
public class LockTest &#123;
    ReentrantLock lock = new ReentrantLock();
    public void a() throws InterruptedException &#123;
        lock.lock();
        System.out.println(lock.getHoldCount());
        doSomething();
        lock.unlock();
        System.out.println(lock.getHoldCount());
    &#125;
    //不可重入
    public void doSomething() throws InterruptedException &#123;
        lock.lock();
        System.out.println(lock.getHoldCount());
        //...................
        lock.unlock();
        System.out.println(lock.getHoldCount());
    &#125;
    public static void main(String[] args) throws InterruptedException &#123;
        LockTest04 test = new LockTest04();
        test.a();            
        Thread.sleep(1000);        
        System.out.println(test.lock.getHoldCount());
    &#125;

&#125;
</code></pre>
<p>结果如下:</p>
<pre><code class="java">1
2
1
0
0
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-多线程并发协作模型-生产者消费者模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%9E%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"
    >多线程并发协作模型-生产者消费者模式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%9E%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-02-27T04:34:09.000Z" itemprop="datePublished">2022-02-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="多线程并发协作模型-生产者消费者模式"><a href="#多线程并发协作模型-生产者消费者模式" class="headerlink" title="多线程并发协作模型-生产者消费者模式"></a>多线程并发协作模型-生产者消费者模式</h1><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul>
<li><p>假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。</p>
</li>
<li><p>如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。</p>
</li>
<li><p>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。</p>
<p><img src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/Producer-consumer-problem.png" alt="Producer-consumer-problem"></p>
</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。</p>
<ul>
<li><p>对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费。</p>
</li>
<li><p>对于消费者，在消费之后，要通知生产者已经消费结束，需要继续生产新产品以供消费。</p>
</li>
<li><p>在生产者消费者问题中，仅有synchronized是不够的。</p>
<ul>
<li>synchronized可阻止并发更新同一个共享资源，实现了同步。</li>
<li>synchronized不能用来实现不同线程之间的消息传递（通信）。</li>
</ul>
</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ul>
<li>并发协作模型-生产者消费者模式—&gt;管程法</li>
<li>并发协作模型-生产者消费者模式—&gt;信号灯法</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a><strong>管程法</strong></h4><p>示例代码如下：</p>
<pre><code class="java">package com.msl.cooperation;
/**
 * 协作模型:生产者消费者实现方式一:管程法
 * 借助缓冲区
 * 
 * @author Senley
 *
 */
public class CoTest01 &#123;
    public static void main(String[] args) &#123;
        SynContainer container = new SynContainer();
        new Productor(container).start();
        new Consumer(container).start();
    &#125;
&#125;
//生产者
class Productor extends Thread&#123;
    SynContainer container  ;    
    public Productor(SynContainer container) &#123;
        this.container = container;
    &#125;

    public void run() &#123;
        //生产
        for(int i=0;i&lt;100;i++) &#123;
            System.out.println(&quot;生产--&gt;&quot;+i+&quot;个馒头&quot;);
            container.push(new Steamedbun(i) );
        &#125;
    &#125;
&#125;
//消费者
class Consumer extends Thread&#123;
    SynContainer container  ;    
    public Consumer(SynContainer container) &#123;
        this.container = container;
    &#125;
    public void run() &#123;
        //消费
        for(int i=0;i&lt;100;i++) &#123;
            System.out.println(&quot;消费--&gt;&quot;+container.pop().id+&quot;个馒头&quot;);
        &#125;
    &#125;
&#125;
//缓冲区
class SynContainer&#123;
    Steamedbun[] buns = new Steamedbun[10]; //存储容器
    int count = 0; //计数器
    //存储 生产
    public synchronized void push(Steamedbun bun) &#123;
        //何时能生产  容器存在空间
        //不能生产 只有等待
        if(count == buns.length) &#123;
            try &#123;
                this.wait(); //线程阻塞  消费者通知生产解除
            &#125; catch (InterruptedException e) &#123;
            &#125;
        &#125;
        //存在空间 可以生产
        buns[count] = bun;
        count++;
        //存在数据了，可以通知消费了
        this.notifyAll();
    &#125;
    //获取 消费
    public synchronized Steamedbun pop() &#123;
        //何时消费 容器中是否存在数据
        //没有数据 只有等待
        if(count == 0) &#123;
            try &#123;
                this.wait(); //线程阻塞  生产者通知消费解除
            &#125; catch (InterruptedException e) &#123;
            &#125;
        &#125;
        //存在数据可以消费
        count --;
        Steamedbun bun = buns[count] ;        
        this.notifyAll(); //存在空间了，可以唤醒对方生产了
        return bun;
    &#125;
&#125;
//馒头
class Steamedbun&#123;
    int id;
    public Steamedbun(int id) &#123;
        this.id = id;
    &#125;
    
&#125;
</code></pre>
<p>结果如下:</p>
<pre><code class="java">生产--&gt;0个馒头
生产--&gt;1个馒头
生产--&gt;2个馒头
生产--&gt;3个馒头
生产--&gt;4个馒头
生产--&gt;5个馒头
生产--&gt;6个馒头
生产--&gt;7个馒头
生产--&gt;8个馒头
生产--&gt;9个馒头
生产--&gt;10个馒头
生产--&gt;11个馒头
消费--&gt;9个馒头
消费--&gt;10个馒头
消费--&gt;11个馒头
消费--&gt;8个馒头
生产--&gt;12个馒头
生产--&gt;13个馒头
消费--&gt;7个馒头
生产--&gt;14个馒头
消费--&gt;13个馒头
生产--&gt;15个馒头
消费--&gt;14个馒头
生产--&gt;16个馒头
消费--&gt;15个馒头
生产--&gt;17个馒头
消费--&gt;16个馒头
生产--&gt;18个馒头
消费--&gt;17个馒头
生产--&gt;19个馒头
生产--&gt;20个馒头
生产--&gt;21个馒头
消费--&gt;18个馒头
消费--&gt;20个馒头
生产--&gt;22个馒头
消费--&gt;21个馒头
消费--&gt;22个馒头
生产--&gt;23个馒头
消费--&gt;19个馒头
生产--&gt;24个馒头
消费--&gt;23个馒头
生产--&gt;25个馒头
消费--&gt;24个馒头
生产--&gt;26个馒头
生产--&gt;27个馒头
生产--&gt;28个馒头
消费--&gt;25个馒头
消费--&gt;27个馒头
生产--&gt;29个馒头
生产--&gt;30个馒头
消费--&gt;28个馒头
消费--&gt;29个馒头
生产--&gt;31个馒头
生产--&gt;32个馒头
消费--&gt;30个馒头
消费--&gt;31个馒头
生产--&gt;33个馒头
生产--&gt;34个馒头
消费--&gt;32个馒头
消费--&gt;33个馒头
生产--&gt;35个馒头
生产--&gt;36个馒头
消费--&gt;34个馒头
消费--&gt;35个馒头
生产--&gt;37个馒头
消费--&gt;36个馒头
生产--&gt;38个馒头
消费--&gt;37个馒头
生产--&gt;39个馒头
消费--&gt;38个馒头
生产--&gt;40个馒头
消费--&gt;39个馒头
生产--&gt;41个馒头
消费--&gt;40个馒头
生产--&gt;42个馒头
消费--&gt;41个馒头
消费--&gt;42个馒头
消费--&gt;26个馒头
消费--&gt;12个馒头
生产--&gt;43个馒头
消费--&gt;6个馒头
消费--&gt;43个馒头
消费--&gt;5个馒头
消费--&gt;4个馒头
消费--&gt;3个馒头
消费--&gt;2个馒头
消费--&gt;1个馒头
消费--&gt;0个馒头
生产--&gt;44个馒头
生产--&gt;45个馒头
消费--&gt;44个馒头
生产--&gt;46个馒头
消费--&gt;45个馒头
生产--&gt;47个馒头
消费--&gt;46个馒头
生产--&gt;48个馒头
消费--&gt;47个馒头
生产--&gt;49个馒头
消费--&gt;48个馒头
生产--&gt;50个馒头
消费--&gt;49个馒头
生产--&gt;51个馒头
消费--&gt;50个馒头
生产--&gt;52个馒头
消费--&gt;51个馒头
生产--&gt;53个馒头
消费--&gt;52个馒头
生产--&gt;54个馒头
消费--&gt;53个馒头
消费--&gt;54个馒头
生产--&gt;55个馒头
生产--&gt;56个馒头
消费--&gt;55个馒头
生产--&gt;57个馒头
消费--&gt;56个馒头
生产--&gt;58个馒头
消费--&gt;57个馒头
生产--&gt;59个馒头
消费--&gt;58个馒头
生产--&gt;60个馒头
消费--&gt;59个馒头
生产--&gt;61个馒头
消费--&gt;60个馒头
生产--&gt;62个馒头
消费--&gt;61个馒头
生产--&gt;63个馒头
消费--&gt;62个馒头
生产--&gt;64个馒头
消费--&gt;63个馒头
消费--&gt;64个馒头
生产--&gt;65个馒头
生产--&gt;66个馒头
消费--&gt;65个馒头
生产--&gt;67个馒头
消费--&gt;66个馒头
生产--&gt;68个馒头
消费--&gt;67个馒头
生产--&gt;69个馒头
消费--&gt;68个馒头
消费--&gt;69个馒头
生产--&gt;70个馒头
生产--&gt;71个馒头
消费--&gt;70个馒头
生产--&gt;72个馒头
消费--&gt;71个馒头
消费--&gt;72个馒头
生产--&gt;73个馒头
生产--&gt;74个馒头
生产--&gt;75个馒头
生产--&gt;76个馒头
消费--&gt;73个馒头
消费--&gt;76个馒头
消费--&gt;75个馒头
消费--&gt;74个馒头
生产--&gt;77个馒头
生产--&gt;78个馒头
消费--&gt;77个馒头
消费--&gt;78个馒头
生产--&gt;79个馒头
消费--&gt;79个馒头
生产--&gt;80个馒头
生产--&gt;81个馒头
消费--&gt;80个馒头
消费--&gt;81个馒头
生产--&gt;82个馒头
生产--&gt;83个馒头
消费--&gt;82个馒头
消费--&gt;83个馒头
生产--&gt;84个馒头
生产--&gt;85个馒头
消费--&gt;84个馒头
消费--&gt;85个馒头
生产--&gt;86个馒头
生产--&gt;87个馒头
消费--&gt;86个馒头
生产--&gt;88个馒头
消费--&gt;87个馒头
生产--&gt;89个馒头
消费--&gt;88个馒头
消费--&gt;89个馒头
生产--&gt;90个馒头
生产--&gt;91个馒头
消费--&gt;90个馒头
消费--&gt;91个馒头
生产--&gt;92个馒头
生产--&gt;93个馒头
消费--&gt;92个馒头
生产--&gt;94个馒头
消费--&gt;93个馒头
生产--&gt;95个馒头
消费--&gt;94个馒头
消费--&gt;95个馒头
生产--&gt;96个馒头
生产--&gt;97个馒头
消费--&gt;96个馒头
消费--&gt;97个馒头
生产--&gt;98个馒头
生产--&gt;99个馒头
消费--&gt;98个馒头
消费--&gt;99个馒头
</code></pre>
<h4 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h4><p>示例代码如下：</p>
<pre><code class="java">package com.msl.cooperation;
/**
 * 协作模型:生产者消费者实现方式二:信号灯法
 * 借助标志位
 * 
 * @author Senley
 *
 */
public class CoTest02 &#123;
    public static void main(String[] args) &#123;
        Tv tv  =new Tv();
        new Player(tv).start();
        new Watcher(tv).start();
    &#125;
&#125;
//生产者 演员
class Player extends Thread&#123;
    Tv tv;    
    public Player(Tv tv) &#123;
        this.tv = tv;
    &#125;

    public void run() &#123;
        for(int i=0;i&lt;20;i++) &#123;
            if(i%2==0) &#123;
                this.tv.play(&quot;欢乐集结号&quot;);
            &#125;else &#123;
                this.tv.play(&quot;怕上火 喝加多宝&quot;);
            &#125;
        &#125;
    &#125;
&#125;
//消费者 观众
class Watcher extends Thread&#123;
    Tv tv;    
    public Watcher(Tv tv) &#123;
        this.tv = tv;
    &#125;

    public void run() &#123;
        for(int i=0;i&lt;20;i++) &#123;
            tv.watch();
        &#125;
    &#125;
&#125;
//同一个资源 电视
class Tv&#123;
    String voice;
    //信号灯
    //T 表示演员表演 观众等待
    //F 表示观众观看 演员等待
    boolean flag = true;
    
    //表演
    public  synchronized void play(String voice) &#123;
        //演员等待
        if(!flag) &#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;        
        //表演
        System.out.println(&quot;表演了:&quot;+voice);
        this.voice = voice;
        //唤醒
        this.notifyAll();
        //切换标志
        this.flag =!this.flag;
    &#125;
    //观看
    public synchronized  void watch() &#123;
        //观众等待
        if(flag) &#123;
            try &#123;
                this.wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        //观看
        System.out.println(&quot;听到了:&quot;+voice);
        //唤醒
        this.notifyAll();
        //切换标志
        this.flag =!this.flag;
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
表演了:欢乐集结号
听到了:欢乐集结号
表演了:怕上火 喝加多宝
听到了:怕上火 喝加多宝
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/" rel="tag">Thread</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-多线程synchronized实现简单的影院购票功能"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BD%B1%E9%99%A2%E8%B4%AD%E7%A5%A8%E5%8A%9F%E8%83%BD/"
    >多线程synchronized实现简单的影院购票功能</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BD%B1%E9%99%A2%E8%B4%AD%E7%A5%A8%E5%8A%9F%E8%83%BD/" class="article-date">
  <time datetime="2022-02-24T16:37:02.000Z" itemprop="datePublished">2022-02-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="多线程synchronized实现简单的影院购票功能"><a href="#多线程synchronized实现简单的影院购票功能" class="headerlink" title="多线程synchronized实现简单的影院购票功能"></a>多线程synchronized实现简单的影院购票功能</h1><p>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突的问题。解决该问题的机制是synchronized关键字，它包括两种用法：synchronized 方法和 synchronized 块。</p>
<h2 id="synchronized-方法"><a href="#synchronized-方法" class="headerlink" title="synchronized 方法"></a><strong>synchronized 方法</strong></h2><p> 通过在方法声明中加入 synchronized关键字来声明，语法如下：</p>
<pre><code class="java">public synchronized void accessVal(int newVal);
</code></pre>
<p>synchronized 方法控制对“对象的类成员变量”的访问：每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。</p>
<h2 id="synchronized-块"><a href="#synchronized-块" class="headerlink" title="synchronized 块"></a><strong>synchronized 块</strong></h2><p>synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率。</p>
<p>Java 为我们提供了更好的解决办法，那就是 synchronized 块。 块可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率。</p>
<p>synchronized 块：通过 synchronized关键字来声明synchronized 块，语法如下：</p>
<pre><code class="java">synchronized(syncObject)
　  &#123; 
　　 //允许访问控制的代码 
　  &#125;
</code></pre>
<h2 id="实现简单的影院购票功能"><a href="#实现简单的影院购票功能" class="headerlink" title="实现简单的影院购票功能"></a>实现简单的影院购票功能</h2><p>代码如下：</p>
<pre><code class="java">package com.msl.syn;

import java.util.ArrayList;
import java.util.List;

/**
 * 实现简单的影院购票功能 - 快乐影院
 * @author Senley
 *
 */
public class HappyCinema2 &#123;
    public static void main(String[] args) &#123;
        //可用位置
        List&lt;Integer&gt; available = new ArrayList&lt;Integer&gt;();
        available.add(1);
        available.add(2);
        available.add(5);
        available.add(6);
        available.add(7);
        //顾客需要的位置
        List&lt;Integer&gt; seats1 = new ArrayList&lt;Integer&gt;();
        seats1.add(1);
        seats1.add(2);
        List&lt;Integer&gt; seats2 = new ArrayList&lt;Integer&gt;();
        seats2.add(3);
        seats2.add(6);
        
        MslCinema m = new MslCinema(available, &quot;Happy Cinema&quot;);
        new Thread(new HappyCustomer(m, seats1),&quot;张三&quot;).start();
        new Thread(new HappyCustomer(m, seats2),&quot;李四&quot;).start();
    &#125;
    
&#125;

//影院
class MslCinema&#123;
    List&lt;Integer&gt; available; //可用的位置
    String name; //名称
    
    public MslCinema(List&lt;Integer&gt; available, String name) &#123;
        this.available = available;
        this.name = name;
    &#125;
    
    //购票
    public boolean bookTickets(List&lt;Integer&gt; seats) &#123;
        System.out.println(&quot;欢迎光临&quot;+this.name+&quot;，可用位置为：&quot;+available);
        List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;();
        copy.addAll(available);
        //相减
        copy.removeAll(seats);
        //判断大小
        if(available.size()-seats.size()!=copy.size()) &#123;
            return false;
        &#125;
        //成功
        available = copy;
        return true;
    &#125;
&#125;

//顾客
class HappyCustomer implements Runnable&#123;
    MslCinema cinema;
    List&lt;Integer&gt; seats;

    public HappyCustomer(MslCinema cinema, List&lt;Integer&gt; seats) &#123;
        super();
        this.cinema = cinema;
        this.seats = seats;
    &#125;

    @Override
    public void run() &#123;
        synchronized(cinema) &#123;
            boolean flag = cinema.bookTickets(seats);
            if(flag) &#123;
                System.out.println(&quot;出票成功--&quot;+Thread.currentThread().getName()+&quot;--位置为&quot;+seats);
            &#125;else &#123;
                System.out.println(&quot;出票失败--&quot;+Thread.currentThread().getName()+&quot;--位置不够&quot;);        
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">欢迎光临Happy Cinema，可用位置为：[1, 2, 5, 6, 7]
出票成功--张三--位置为[1, 2]
欢迎光临Happy Cinema，可用位置为：[5, 6, 7]
出票失败--李四--位置不够
</code></pre>
<p>“synchronized (cinema)” 意味着线程需要获得cinema对象的“锁”才有资格运行同步块中的代码。cinema对象的“锁”也称为“互斥锁”，在同一时刻只能被一个线程使用。A线程拥有锁，则可以调用“同步块”中的代码；B线程没有锁，则进入cinema对象的“锁池队列”等待，直到A线程使用完毕释放了cinema对象的锁，B线程得到锁才可以开始调用“同步块”中的代码。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/" rel="tag">Thread</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-多线程的实现方式及简单模拟"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F/"
    >多线程的实现方式及简单模拟</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F/" class="article-date">
  <time datetime="2022-02-21T16:36:03.000Z" itemprop="datePublished">2022-02-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="多线程的实现方式及简单模拟"><a href="#多线程的实现方式及简单模拟" class="headerlink" title="多线程的实现方式及简单模拟"></a>多线程的实现方式及简单模拟</h1><h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><ol>
<li>继承Thread类<ul>
<li>1、创建：继承Thread + 重写run</li>
<li>2、启动：创建子类对象 + start</li>
</ul>
</li>
<li>Runnable接口（<strong>避免单继承的局限性，优先使用接口</strong>）<ul>
<li>1、创建：实现Runnable + 重写run</li>
<li>2、启动：创建实现类对象 + Thread对象 + start</li>
</ul>
</li>
<li>Callable接口<ul>
<li>1、创建目标对象</li>
<li>2、创建执行服务</li>
<li>3、提交执行</li>
<li>4、获取结果</li>
<li>5、关闭服务</li>
</ul>
</li>
</ol>
<h2 id="多线程的简单模拟"><a href="#多线程的简单模拟" class="headerlink" title="多线程的简单模拟"></a>多线程的简单模拟</h2><h3 id="模拟12306"><a href="#模拟12306" class="headerlink" title="模拟12306"></a>模拟12306</h3><p>代码如下：</p>
<pre><code class="java">package com.msl.thread;
/**
 * 模拟12306
 * @author Senley
 *
 */
public class Web12306 implements Runnable &#123;
    //票数
    private int ticketNums = 99;
    
    @Override
    public void run() &#123;
        while(true) &#123;
            if(ticketNums&lt;0) &#123;
                break;
            &#125;
            try &#123;
                Thread.sleep(200);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+ticketNums--);
        &#125;
    &#125;
    
    public static void main(String[] args) &#123;
        //一份资源
        Web12306 web = new Web12306();
        System.out.println(Thread.currentThread().getName());
        //多个代理
        new Thread(web,&quot;码畜&quot;).start();
        new Thread(web,&quot;码农&quot;).start();
        new Thread(web,&quot;码蟥&quot;).start();
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">main
码畜--&gt;99
码蟥--&gt;97
码农--&gt;98
码农--&gt;96
码蟥--&gt;96
码畜--&gt;96
码畜--&gt;95
码农--&gt;95
码蟥--&gt;95
码畜--&gt;94
码农--&gt;94
码蟥--&gt;93
码蟥--&gt;92
码农--&gt;91
码畜--&gt;90
码畜--&gt;89
码农--&gt;88
码蟥--&gt;88
码蟥--&gt;87
码畜--&gt;86
码农--&gt;85
码蟥--&gt;84
码农--&gt;84
码畜--&gt;83
码畜--&gt;82
码蟥--&gt;82
码农--&gt;82
码蟥--&gt;80
码农--&gt;81
码畜--&gt;81
码畜--&gt;79
码蟥--&gt;78
码农--&gt;79
码农--&gt;77
码畜--&gt;77
码蟥--&gt;77
码畜--&gt;76
码农--&gt;74
码蟥--&gt;75
码农--&gt;73
码蟥--&gt;72
码畜--&gt;73
码农--&gt;71
码畜--&gt;71
码蟥--&gt;70
码农--&gt;69
码蟥--&gt;68
码畜--&gt;69
码蟥--&gt;66
码农--&gt;67
码畜--&gt;65
码蟥--&gt;62
码农--&gt;63
码畜--&gt;64
码畜--&gt;61
码蟥--&gt;60
码农--&gt;59
码畜--&gt;58
码蟥--&gt;57
码农--&gt;58
码农--&gt;56
码畜--&gt;56
码蟥--&gt;56
码蟥--&gt;55
码农--&gt;55
码畜--&gt;54
码蟥--&gt;53
码农--&gt;51
码畜--&gt;52
码畜--&gt;50
码蟥--&gt;50
码农--&gt;50
码农--&gt;48
码蟥--&gt;49
码畜--&gt;47
码畜--&gt;44
码农--&gt;45
码蟥--&gt;46
码畜--&gt;43
码农--&gt;41
码蟥--&gt;42
码农--&gt;39
码畜--&gt;40
码蟥--&gt;40
码畜--&gt;38
码农--&gt;38
码蟥--&gt;38
码畜--&gt;37
码农--&gt;37
码蟥--&gt;37
码蟥--&gt;35
码农--&gt;35
码畜--&gt;36
码畜--&gt;34
码蟥--&gt;34
码农--&gt;34
码农--&gt;33
码畜--&gt;33
码蟥--&gt;33
码蟥--&gt;32
码农--&gt;32
码畜--&gt;32
码畜--&gt;31
码农--&gt;31
码蟥--&gt;31
码蟥--&gt;30
码畜--&gt;30
码农--&gt;30
码农--&gt;29
码蟥--&gt;28
码畜--&gt;29
码畜--&gt;27
码农--&gt;26
码蟥--&gt;27
码畜--&gt;25
码农--&gt;25
码蟥--&gt;25
码蟥--&gt;24
码农--&gt;23
码畜--&gt;23
码蟥--&gt;22
码农--&gt;22
码畜--&gt;22
码畜--&gt;21
码蟥--&gt;19
码农--&gt;20
码蟥--&gt;18
码畜--&gt;18
码农--&gt;17
码蟥--&gt;16
码农--&gt;15
码畜--&gt;14
码畜--&gt;13
码农--&gt;13
码蟥--&gt;13
码蟥--&gt;12
码农--&gt;11
码畜--&gt;12
码农--&gt;10
码畜--&gt;9
码蟥--&gt;8
码农--&gt;7
码畜--&gt;6
码蟥--&gt;7
码畜--&gt;5
码农--&gt;3
码蟥--&gt;4
码蟥--&gt;2
码农--&gt;2
码畜--&gt;2
码畜--&gt;0
码农--&gt;1
码蟥--&gt;1
</code></pre>
<h3 id="模拟龟兔赛跑"><a href="#模拟龟兔赛跑" class="headerlink" title="模拟龟兔赛跑"></a>模拟龟兔赛跑</h3><p>代码如下：</p>
<pre><code class="java">package com.msl.thread;
/**
 * 模拟龟兔赛跑
 * @author Senley
 *
 */
public class Racer implements Runnable&#123;
    private String winner;//胜利者
    @Override
    public void run() &#123;
        for(int steps=1;steps&lt;=100;steps++) &#123;
            //模拟休息
            if(Thread.currentThread().getName().equals(&quot;rabbit&quot;)&amp;&amp;steps%10==0) &#123;
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+steps);
            //比赛是否结束
            boolean flag = gameOver(steps);
            if(flag) &#123;
                break;
            &#125;
        &#125;
    &#125;
    
    private boolean gameOver(int steps) &#123;
        if(winner!=null) &#123;//存在胜利者
            return true;
        &#125;else &#123;
            if(steps==100) &#123;
                winner = Thread.currentThread().getName();
                System.out.println(&quot;winner--&gt;&quot;+winner);
                return true;
            &#125;
        &#125;
        return false;
    &#125;
    
    public static void main(String[] args) &#123;
        Racer racer = new Racer();
        new Thread(racer,&quot;tortoise&quot;).start();
        new Thread(racer,&quot;rabbit&quot;).start();
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">tortoise--&gt;1
rabbit--&gt;1
rabbit--&gt;2
rabbit--&gt;3
rabbit--&gt;4
rabbit--&gt;5
rabbit--&gt;6
rabbit--&gt;7
rabbit--&gt;8
rabbit--&gt;9
tortoise--&gt;2
tortoise--&gt;3
tortoise--&gt;4
tortoise--&gt;5
tortoise--&gt;6
tortoise--&gt;7
tortoise--&gt;8
tortoise--&gt;9
tortoise--&gt;10
tortoise--&gt;11
tortoise--&gt;12
tortoise--&gt;13
tortoise--&gt;14
tortoise--&gt;15
tortoise--&gt;16
tortoise--&gt;17
tortoise--&gt;18
tortoise--&gt;19
tortoise--&gt;20
tortoise--&gt;21
tortoise--&gt;22
tortoise--&gt;23
tortoise--&gt;24
tortoise--&gt;25
tortoise--&gt;26
tortoise--&gt;27
tortoise--&gt;28
tortoise--&gt;29
tortoise--&gt;30
tortoise--&gt;31
tortoise--&gt;32
tortoise--&gt;33
tortoise--&gt;34
tortoise--&gt;35
tortoise--&gt;36
tortoise--&gt;37
tortoise--&gt;38
tortoise--&gt;39
tortoise--&gt;40
tortoise--&gt;41
tortoise--&gt;42
tortoise--&gt;43
tortoise--&gt;44
tortoise--&gt;45
tortoise--&gt;46
tortoise--&gt;47
tortoise--&gt;48
tortoise--&gt;49
tortoise--&gt;50
tortoise--&gt;51
tortoise--&gt;52
tortoise--&gt;53
tortoise--&gt;54
tortoise--&gt;55
tortoise--&gt;56
tortoise--&gt;57
tortoise--&gt;58
tortoise--&gt;59
tortoise--&gt;60
tortoise--&gt;61
tortoise--&gt;62
tortoise--&gt;63
tortoise--&gt;64
tortoise--&gt;65
tortoise--&gt;66
tortoise--&gt;67
tortoise--&gt;68
tortoise--&gt;69
tortoise--&gt;70
tortoise--&gt;71
tortoise--&gt;72
tortoise--&gt;73
tortoise--&gt;74
tortoise--&gt;75
tortoise--&gt;76
tortoise--&gt;77
tortoise--&gt;78
tortoise--&gt;79
tortoise--&gt;80
tortoise--&gt;81
tortoise--&gt;82
tortoise--&gt;83
tortoise--&gt;84
tortoise--&gt;85
tortoise--&gt;86
tortoise--&gt;87
tortoise--&gt;88
tortoise--&gt;89
tortoise--&gt;90
tortoise--&gt;91
tortoise--&gt;92
tortoise--&gt;93
tortoise--&gt;94
tortoise--&gt;95
tortoise--&gt;96
tortoise--&gt;97
tortoise--&gt;98
tortoise--&gt;99
tortoise--&gt;100
winner--&gt;tortoise
rabbit--&gt;10
</code></pre>
<h3 id="模拟龟兔赛跑（使用Callable）"><a href="#模拟龟兔赛跑（使用Callable）" class="headerlink" title="模拟龟兔赛跑（使用Callable）"></a>模拟龟兔赛跑（使用Callable）</h3><p>代码如下：</p>
<pre><code class="java">package com.msl.thread;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * 模拟龟兔赛跑
 * @author Senley
 *
 */
public class CRacer implements Callable&lt;Integer&gt;&#123;
    private String winner;//胜利者
    @Override
    public Integer call() throws Exception &#123;
        for(int steps=1;steps&lt;=100;steps++) &#123;
            //模拟休息
            if(Thread.currentThread().getName().equals(&quot;pool-1-thread-1&quot;)&amp;&amp;steps%10==0) &#123;
                Thread.sleep(100);
            &#125;
            System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+steps);
            //比赛是否结束
            boolean flag = gameOver(steps);
            if(flag) &#123;
                return steps;
            &#125;
        &#125;
        return null;
    &#125;
    
    private boolean gameOver(int steps) &#123;
        if(winner!=null) &#123;//存在胜利者
            return true;
        &#125;else &#123;
            if(steps==100) &#123;
                winner = Thread.currentThread().getName();
                System.out.println(&quot;winner--&gt;&quot;+winner);
                return true;
            &#125;
        &#125;
        return false;
    &#125;
    
    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;
        CRacer racer = new CRacer();
        //创建执行服务: 
        ExecutorService  ser=Executors.newFixedThreadPool(2);
        //提交执行: 
        Future&lt;Integer&gt; result1 =ser.submit(racer) ;
        Future&lt;Integer&gt; result2 =ser.submit(racer) ;
        //获取结果:  
        Integer r1 =result1.get();
        Integer r2 =result2.get();
        System.out.println(r1+&quot;--&gt;&quot;+r2);
        //关闭服务:  
        ser.shutdownNow();
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">pool-1-thread-2--&gt;1
pool-1-thread-1--&gt;1
pool-1-thread-1--&gt;2
pool-1-thread-1--&gt;3
pool-1-thread-1--&gt;4
pool-1-thread-1--&gt;5
pool-1-thread-1--&gt;6
pool-1-thread-1--&gt;7
pool-1-thread-1--&gt;8
pool-1-thread-1--&gt;9
pool-1-thread-2--&gt;2
pool-1-thread-2--&gt;3
pool-1-thread-2--&gt;4
pool-1-thread-2--&gt;5
pool-1-thread-2--&gt;6
pool-1-thread-2--&gt;7
pool-1-thread-2--&gt;8
pool-1-thread-2--&gt;9
pool-1-thread-2--&gt;10
pool-1-thread-2--&gt;11
pool-1-thread-2--&gt;12
pool-1-thread-2--&gt;13
pool-1-thread-2--&gt;14
pool-1-thread-2--&gt;15
pool-1-thread-2--&gt;16
pool-1-thread-2--&gt;17
pool-1-thread-2--&gt;18
pool-1-thread-2--&gt;19
pool-1-thread-2--&gt;20
pool-1-thread-2--&gt;21
pool-1-thread-2--&gt;22
pool-1-thread-2--&gt;23
pool-1-thread-2--&gt;24
pool-1-thread-2--&gt;25
pool-1-thread-2--&gt;26
pool-1-thread-2--&gt;27
pool-1-thread-2--&gt;28
pool-1-thread-2--&gt;29
pool-1-thread-2--&gt;30
pool-1-thread-2--&gt;31
pool-1-thread-2--&gt;32
pool-1-thread-2--&gt;33
pool-1-thread-2--&gt;34
pool-1-thread-2--&gt;35
pool-1-thread-2--&gt;36
pool-1-thread-2--&gt;37
pool-1-thread-2--&gt;38
pool-1-thread-2--&gt;39
pool-1-thread-2--&gt;40
pool-1-thread-2--&gt;41
pool-1-thread-2--&gt;42
pool-1-thread-2--&gt;43
pool-1-thread-2--&gt;44
pool-1-thread-2--&gt;45
pool-1-thread-2--&gt;46
pool-1-thread-2--&gt;47
pool-1-thread-2--&gt;48
pool-1-thread-2--&gt;49
pool-1-thread-2--&gt;50
pool-1-thread-2--&gt;51
pool-1-thread-2--&gt;52
pool-1-thread-2--&gt;53
pool-1-thread-2--&gt;54
pool-1-thread-2--&gt;55
pool-1-thread-2--&gt;56
pool-1-thread-2--&gt;57
pool-1-thread-2--&gt;58
pool-1-thread-2--&gt;59
pool-1-thread-2--&gt;60
pool-1-thread-2--&gt;61
pool-1-thread-2--&gt;62
pool-1-thread-2--&gt;63
pool-1-thread-2--&gt;64
pool-1-thread-2--&gt;65
pool-1-thread-2--&gt;66
pool-1-thread-2--&gt;67
pool-1-thread-2--&gt;68
pool-1-thread-2--&gt;69
pool-1-thread-2--&gt;70
pool-1-thread-2--&gt;71
pool-1-thread-2--&gt;72
pool-1-thread-2--&gt;73
pool-1-thread-2--&gt;74
pool-1-thread-2--&gt;75
pool-1-thread-2--&gt;76
pool-1-thread-2--&gt;77
pool-1-thread-2--&gt;78
pool-1-thread-2--&gt;79
pool-1-thread-2--&gt;80
pool-1-thread-2--&gt;81
pool-1-thread-2--&gt;82
pool-1-thread-2--&gt;83
pool-1-thread-2--&gt;84
pool-1-thread-2--&gt;85
pool-1-thread-2--&gt;86
pool-1-thread-2--&gt;87
pool-1-thread-2--&gt;88
pool-1-thread-2--&gt;89
pool-1-thread-2--&gt;90
pool-1-thread-2--&gt;91
pool-1-thread-2--&gt;92
pool-1-thread-2--&gt;93
pool-1-thread-2--&gt;94
pool-1-thread-2--&gt;95
pool-1-thread-2--&gt;96
pool-1-thread-2--&gt;97
pool-1-thread-2--&gt;98
pool-1-thread-2--&gt;99
pool-1-thread-2--&gt;100
winner--&gt;pool-1-thread-2
pool-1-thread-1--&gt;10
10--&gt;100
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/" rel="tag">Thread</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-装饰器设计模式的理解与实现"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/14/%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/"
    >装饰器设计模式的理解与实现</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/14/%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2022-01-13T17:22:05.000Z" itemprop="datePublished">2022-01-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="装饰器设计模式的理解与实现"><a href="#装饰器设计模式的理解与实现" class="headerlink" title="装饰器设计模式的理解与实现"></a><strong>装饰器设计模式</strong>的理解与实现</h1><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<h2 id="装饰器设计模式的定义与特点"><a href="#装饰器设计模式的定义与特点" class="headerlink" title="装饰器设计模式的定义与特点"></a>装饰器设计模式的定义与特点</h2><p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰（Decorator）模式的主要优点有：</p>
<ul>
<li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态地给一个对象扩展功能，即插即用。</li>
<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果。</li>
<li>装饰器模式完全遵守开闭原则。</li>
</ul>
<p>其主要缺点是：</p>
<p>装饰模式会增加许多子类，过度使用会增加程序复杂性。</p>
<h2 id="装饰器设计模式的结构与实现"><a href="#装饰器设计模式的结构与实现" class="headerlink" title="装饰器设计模式的结构与实现"></a>装饰器设计模式的结构与实现</h2><h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><ul>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<h3 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h3><p>代码如下：</p>
<pre><code class="java">package com.msl.io;
/**
 * 模拟咖啡
 * 1、抽象组件:需要装饰的抽象对象(接口或抽象父类)
 * 2、具体组件:需要装饰的对象
 * 3、抽象装饰类:包含了对抽象组件的引用以及装饰者共有的方法
 * 4、具体装饰类:被装饰的对象
 * @author Senley
 *
 */
public class DecorateTest &#123;
    public static void main(String[] args) &#123;
        Drink coffer = new Coffer();
        Drink suger = new Suger(coffer);//装饰
        System.out.println(suger.info()+&quot;--&gt;&quot;+suger.cost());
        Drink milk = new Milk(coffer);//装饰
        System.out.println(milk.info()+&quot;--&gt;&quot;+milk.cost());
        milk = new Milk(suger);//装饰
        System.out.println(milk.info()+&quot;--&gt;&quot;+milk.cost());
    &#125;
&#125;

//抽象组件
interface Drink&#123;
    double cost();//费用
    String info();//说明
&#125;

//具体组件
class Coffer implements Drink&#123;
    private String name =&quot;原味咖啡&quot;;
    @Override
    public double cost() &#123;
        return 10;
    &#125;

    @Override
    public String info() &#123;
        return name;
    &#125;
&#125;

//抽象装饰类
abstract class Decorate implements Drink&#123;
    //对抽象组件的引用
    private Drink drink;
    public Decorate(Drink drink) &#123;
        this.drink = drink;
    &#125;
    @Override
    public double cost() &#123;
        return this.drink.cost();
    &#125;

    @Override
    public String info() &#123;
        return this.drink.info();
    &#125;
&#125;

//具体装饰类
class Milk extends Decorate&#123;
    public Milk(Drink drink) &#123;
        super(drink);
    &#125;
    @Override
    public double cost() &#123;
        return super.cost()*4;
    &#125;

    @Override
    public String info() &#123;
        return super.info()+&quot;加入了牛奶&quot;;
    &#125;
&#125;

class Suger extends Decorate&#123;
    public Suger(Drink drink) &#123;
        super(drink);
    &#125;
    @Override
    public double cost() &#123;
        return super.cost()*2;
    &#125;

    @Override
    public String info() &#123;
        return super.info()+&quot;加入了蔗糖&quot;;
    &#125;    
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">原味咖啡加入了蔗糖--&gt;20.0
原味咖啡加入了牛奶--&gt;40.0
原味咖啡加入了蔗糖加入了牛奶--&gt;80.0
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DesignPattern/" rel="tag">DesignPattern</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-IO文件拷贝与对接流"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/01/IO%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%AF%B9%E6%8E%A5%E6%B5%81/"
    >IO文件拷贝与对接流</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/01/IO%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%AF%B9%E6%8E%A5%E6%B5%81/" class="article-date">
  <time datetime="2022-01-01T08:01:06.000Z" itemprop="datePublished">2022-01-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="IO文件拷贝与对接流"><a href="#IO文件拷贝与对接流" class="headerlink" title="IO文件拷贝与对接流"></a>IO文件拷贝与对接流</h1><h2 id="IO文件拷贝"><a href="#IO文件拷贝" class="headerlink" title="IO文件拷贝"></a>IO文件拷贝</h2><p>IO文件拷贝：文件字节输入输出流。</p>
<ol>
<li>创建源</li>
<li>选择流</li>
<li>操作</li>
<li>释放资源</li>
</ol>
<p>代码如下：</p>
<pre><code class="java">package com.msl.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * 文件拷贝：文件字节输入、输出流
 * 1、创建源
 * 2、选择流
 * 3、操作（写出内容）
 * 4、释放资源
 * @author Senley
 *
 */
public class Copy &#123;

    public static void main(String[] args) &#123;
        copy(&quot;src/com/msl/io/Copy.java&quot;,&quot;copy.txt&quot;);
    &#125;
    /**
     * 文件的拷贝
     * @param srcPath
     * @param destPath
     */
    public static void copy(String srcPath,String destPath) &#123;
        //1、创建源
        File src = new File(srcPath);//源头
        File dest = new File(destPath);//目的地
        //2、选择流
        InputStream is = null;
        OutputStream os = null;
        try &#123;
            is = new FileInputStream(src);
            os = new FileOutputStream(dest);
            //3、操作
            byte[] flush = new byte[1024];//缓冲容器
            int len = -1;//接收长度
            while((len=is.read(flush))!=-1) &#123;
                os.write(flush,0,len);
            &#125;
        &#125;catch(FileNotFoundException e)&#123;
            e.printStackTrace();
        &#125;catch(IOException e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            //释放资源 分别关闭 先打开的后关闭
            try &#123;
                if (null != os) &#123;
                    os.close();
                &#125; 
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
            
            try &#123;
                if(null!=is) &#123;
                    is.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

&#125;
</code></pre>
<h2 id="IO对接流"><a href="#IO对接流" class="headerlink" title="IO对接流"></a>IO对接流</h2><ol>
<li><p>图片读取到字节数组</p>
<p>1)图片到程序</p>
<p>2)程序到字节数组</p>
</li>
<li><p>字节数组写出到文件</p>
<p>1)字节数组到程序</p>
<p>2)程序到文件</p>
</li>
</ol>
<p>代码如下：</p>
<pre><code class="java">package com.msl.io;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * 1、图片读取到字节数组
 * 2、字节数组写出到文件
 * @author Senley
 *
 */
public class IOTest &#123;

    public static void main(String[] args) &#123;
        //图片转成字节数组
        byte[] datas = fileToByteArray(&quot;p.png&quot;);
        System.out.println(datas.length);
        byteArrayToFile(datas, &quot;p-byte.png&quot;);
    &#125;
    
    /**
     * 1、图片读取到字节数组
     * 1)、图片到程序 FileInputStream
     * 2)、程序到字节数组 ByteArrayOutputStream
     */
    public static byte[] fileToByteArray(String filePath) &#123;
        //1、创建源与目的地
        File src = new File(filePath);
        byte[] dest = null;
        //2、选择流
        InputStream is = null;
        ByteArrayOutputStream baos = null;
        try &#123;
            is = new FileInputStream(src);
            baos = new ByteArrayOutputStream();
            //3、操作（分段读取）
            byte[] flush = new byte[1024*10];//缓冲容器
            int len = -1;//接收长度
            while((len=is.read(flush))!=-1) &#123;
                baos.write(flush,0,len); //写出到字节数组中
            &#125;
            baos.flush();
            return baos.toByteArray();
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            //4、释放资源
            try &#123;
                if(null!=is) &#123;
                    is.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        return null;
    &#125;
    /**
     * 2、字节数组写出到文件
     * 1)、字节数组到程序 ByteArrayInputStream
     * 2)、程序到文件 FileOutputStream
     */
    public static void byteArrayToFile(byte[] src,String filePath) &#123;
        //1、创建源
        File dest = new File(filePath);
        //2、选择流
        InputStream is = null;
        OutputStream os = null;
        try &#123;
            is = new ByteArrayInputStream(src);
            os = new FileOutputStream(dest);
            //3、操作（分段读取）
            byte[] flush = new byte[5];//缓冲容器
            int len = -1;//接收长度
            while((len=is.read(flush))!=-1) &#123;
                os.write(flush,0,len);//写出到文件
            &#125;
            os.flush();
        &#125;catch (IOException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            //4、释放资源
            try &#123;
                if (null != os) &#123;
                    os.close();
                &#125; 
            &#125; catch (Exception e) &#123;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO/" rel="tag">IO</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-使用递归及面向对象思想统计文件夹大小"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/26/%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%8F%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F/"
    >使用递归及面向对象思想统计文件夹大小</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/26/%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%8F%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F/" class="article-date">
  <time datetime="2021-11-26T15:40:12.000Z" itemprop="datePublished">2021-11-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="使用递归及面向对象思想统计文件夹大小"><a href="#使用递归及面向对象思想统计文件夹大小" class="headerlink" title="使用递归及面向对象思想统计文件夹大小"></a><strong>使用递归及面向对象思想统计文件夹大小</strong></h1><h2 id="IO介绍"><a href="#IO介绍" class="headerlink" title="IO介绍"></a>IO介绍</h2><p>对于任何程序设计语言而言，输入输出(Input/Output)系统都是非常核心的功能。程序运行需要数据，数据的获取往往需要跟外部系统进行通信，外部系统可能是文件、数据库、其他程序、网络、IO设备等等。外部系统比较复杂多变，那么就有必要通过某种手段进行抽象、屏蔽外部的差异，从而实现更加便捷的编程。</p>
<p>输入(Input)指的是：可以让程序从外部系统获得数据(核心含义是“读”，读取外部数据)。常见的应用：</p>
<ul>
<li>读取硬盘上的文件内容到程序。例如：播放器打开一个视频文件、word打开一个doc文件。</li>
<li>读取网络上某个位置内容到程序。例如：浏览器中输入网址后，打开该网址对应的网页内容；下载网络上某个网址的文件。</li>
<li>读取数据库系统的数据到程序。</li>
<li>读取某些硬件系统数据到程序。例如：车载电脑读取雷达扫描信息到程序；温控系统等。</li>
</ul>
<p>输出(Output)指的是：程序输出数据给外部系统从而可以操作外部系统(核心含义是“写”，将数据写出到外部系统)。常见的应用有：</p>
<ul>
<li>将数据写到硬盘中。例如：我们编辑完一个word文档后，将内容写到硬盘上进行保存。</li>
<li>将数据写到数据库系统中。例如：我们注册一个网站会员，实际就是后台程序向数据库中写入一条记录。</li>
<li>将数据写到某些硬件系统中。例如：导弹系统导航程序将新的路径输出到飞控子系统，飞控子系统根据数据修正飞行路径。</li>
</ul>
<h2 id="File类介绍"><a href="#File类介绍" class="headerlink" title="File类介绍"></a>File类介绍</h2><p>Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。</p>
<p>File对象代表磁盘中实际存在的文件和目录。通过以下构造方法创建一个File对象。</p>
<p>通过给定的父抽象路径名和子路径名字符串创建一个新的File实例。</p>
<pre><code class="java">File(File parent, String child);
</code></pre>
<p>通过将给定路径名字符串转换成抽象路径名来创建一个新 File 实例。</p>
<pre><code class="java">File(String pathname) 
</code></pre>
<p>根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。</p>
<pre><code class="java">File(String parent, String child) 
</code></pre>
<p>通过将给定的 file: URI 转换成一个抽象路径名来创建一个新的 File 实例。</p>
<pre><code class="java">File(URI uri) 
</code></pre>
<p>创建File对象成功后，可以使用以下列表中的方法操作文件。</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><strong>public String getName()</strong> 返回由此抽象路径名表示的文件或目录的名称。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">**public String getParent()**<strong>、</strong>  返回此抽象路径名的父路径名的路径名字符串，如果此路径名没有指定父目录，则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><strong>public File getParentFile()</strong> 返回此抽象路径名的父路径名的抽象路径名，如果此路径名没有指定父目录，则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><strong>public String getPath()</strong> 将此抽象路径名转换为一个路径名字符串。</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><strong>public boolean isAbsolute()</strong> 测试此抽象路径名是否为绝对路径名。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left"><strong>public String getAbsolutePath()</strong> 返回抽象路径名的绝对路径名字符串。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left"><strong>public boolean canRead()</strong> 测试应用程序是否可以读取此抽象路径名表示的文件。</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left"><strong>public boolean canWrite()</strong> 测试应用程序是否可以修改此抽象路径名表示的文件。</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left"><strong>public boolean exists()</strong> 测试此抽象路径名表示的文件或目录是否存在。</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left"><strong>public boolean isDirectory()</strong> 测试此抽象路径名表示的文件是否是一个目录。</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left"><strong>public boolean isFile()</strong> 测试此抽象路径名表示的文件是否是一个标准文件。</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left"><strong>public long lastModified()</strong> 返回此抽象路径名表示的文件最后一次被修改的时间。</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left"><strong>public long length()</strong> 返回由此抽象路径名表示的文件的长度。</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left"><strong>public boolean createNewFile() throws IOException</strong> 当且仅当不存在具有此抽象路径名指定的名称的文件时，原子地创建由此抽象路径名指定的一个新的空文件。</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left"><strong>public boolean delete()</strong>  删除此抽象路径名表示的文件或目录。</td>
</tr>
<tr>
<td align="center">16</td>
<td align="left"><strong>public void deleteOnExit()</strong> 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。</td>
</tr>
<tr>
<td align="center">17</td>
<td align="left"><strong>public String[] list()</strong> 返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。</td>
</tr>
<tr>
<td align="center">18</td>
<td align="left"><strong>public String[] list(FilenameFilter filter)</strong> 返回由包含在目录中的文件和目录的名称所组成的字符串数组，这一目录是通过满足指定过滤器的抽象路径名来表示的。</td>
</tr>
<tr>
<td align="center">19</td>
<td align="left"><strong>public File[] listFiles()</strong>  返回一个抽象路径名数组，这些路径名表示此抽象路径名所表示目录中的文件。</td>
</tr>
<tr>
<td align="center">20</td>
<td align="left"><strong>public File[] listFiles(FileFilter filter)</strong> 返回表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组，这些路径名满足特定过滤器。</td>
</tr>
<tr>
<td align="center">21</td>
<td align="left"><strong>public boolean mkdir()</strong> 创建此抽象路径名指定的目录。</td>
</tr>
<tr>
<td align="center">22</td>
<td align="left"><strong>public boolean mkdirs()</strong> 创建此抽象路径名指定的目录，包括创建必需但不存在的父目录。</td>
</tr>
<tr>
<td align="center">23</td>
<td align="left"><strong>public boolean renameTo(File dest)</strong>  重新命名此抽象路径名表示的文件。</td>
</tr>
<tr>
<td align="center">24</td>
<td align="left"><strong>public boolean setLastModified(long time)</strong> 设置由此抽象路径名所指定的文件或目录的最后一次修改时间。</td>
</tr>
<tr>
<td align="center">25</td>
<td align="left"><strong>public boolean setReadOnly()</strong> 标记此抽象路径名指定的文件或目录，以便只可对其进行读操作。</td>
</tr>
<tr>
<td align="center">26</td>
<td align="left"><strong>public static File createTempFile(String prefix, String suffix, File directory) throws IOException</strong> 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</td>
</tr>
<tr>
<td align="center">27</td>
<td align="left"><strong>public static File createTempFile(String prefix, String suffix) throws IOException</strong> 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。</td>
</tr>
<tr>
<td align="center">28</td>
<td align="left"><strong>public int compareTo(File pathname)</strong> 按字母顺序比较两个抽象路径名。</td>
</tr>
<tr>
<td align="center">29</td>
<td align="left"><strong>public int compareTo(Object o)</strong> 按字母顺序比较抽象路径名与给定对象。</td>
</tr>
<tr>
<td align="center">30</td>
<td align="left"><strong>public boolean equals(Object obj)</strong> 测试此抽象路径名与给定对象是否相等。</td>
</tr>
<tr>
<td align="center">31</td>
<td align="left"><strong>public String toString()</strong>  返回此抽象路径名的路径名字符串。</td>
</tr>
</tbody></table>
<h2 id="使用递归及面向对象思想统计文件夹大小、文件个数、文件夹个数"><a href="#使用递归及面向对象思想统计文件夹大小、文件个数、文件夹个数" class="headerlink" title="使用递归及面向对象思想统计文件夹大小、文件个数、文件夹个数"></a>使用递归及面向对象思想统计文件夹大小、文件个数、文件夹个数</h2><p>代码如下：</p>
<pre><code class="java">package com.msl.io;

import java.io.File;

/**
 * 使用递归及面向对象: 统计文件夹大小、文件个数、文件夹个数
 * @author Senley
 * 
 */
public class DirSize &#123;
    //大小
    private long len;
    //文件夹路径
    private String path;
    //文件个数
    private int fileCount;
    //文件夹个数
    private int dirCount;
    //源
    private File src;
    
    public long getLen() &#123;
        return len;
    &#125;
    
    public int getFileCount() &#123;
        return fileCount;
    &#125;

    public int getDirCount() &#123;
        return dirCount;
    &#125;
    
    public DirSize(String path) &#123;
        this.path = path;
        this.src = new File(path);
        count(src);
    &#125;

    public static void main(String[] args) &#123;
        DirSize dir = new DirSize(&quot;E:/Workspace/IO&quot;);
        System.out.println(&quot;文件夹大小：&quot;+dir.getLen()+&quot;字节&quot;+ &quot;--&quot;+&quot;文件个数：&quot;+dir.getFileCount()+&quot; --&quot;+&quot;文件夹个数：&quot;+dir.getDirCount());
    &#125;
    
    //统计大小
    private void count(File src)&#123;
        //获取大小
        if(null!=src &amp;&amp; src.exists()) &#123;
            if(src.isFile()) &#123;//大小
                fileCount++;
                len+=src.length();
            &#125;else&#123;//子孙级
                dirCount++;
                for(File s:src.listFiles()) &#123;
                    count(s);
                &#125;
            &#125;
        &#125;
    &#125;

&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">文件夹大小：60850字节 --文件个数：29 --文件夹个数：13
</code></pre>
<p>需注意的是，文件夹个数为子孙级文件夹个数+本身，如需仅显示子孙级文件夹，可定义dirCount = -1。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/File/" rel="tag">File</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-使用容器存储表格数据"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/22/%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE/"
    >使用容器存储表格数据</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/22/%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE/" class="article-date">
  <time datetime="2021-11-21T17:52:12.000Z" itemprop="datePublished">2021-11-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="使用容器存储表格数据"><a href="#使用容器存储表格数据" class="headerlink" title="使用容器存储表格数据"></a><strong>使用容器存储表格数据</strong></h1><p>使用容器存储以下表格数据。</p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">姓名</th>
<th align="center">薪水</th>
<th align="center">入职日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1001</td>
<td align="center">张三</td>
<td align="center">20000</td>
<td align="center">2018.5.5</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">李四</td>
<td align="center">30000</td>
<td align="center">2005.5.4</td>
</tr>
<tr>
<td align="center">1003</td>
<td align="center">王五</td>
<td align="center">3000</td>
<td align="center">2020.5.4</td>
</tr>
</tbody></table>
<h2 id="Map和List结合存储"><a href="#Map和List结合存储" class="headerlink" title="Map和List结合存储"></a>Map和List结合存储</h2><p>Map表示一行数据，多行数据是多个Map，将多个Map放到List中。代码如下：</p>
<pre><code class="java">package com.msl.collection;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * 测试表格数据的存储
 * ORM思想的简单实验：map表示一行数据，多行数据是多个map；将多个map放到list中
 * @author Senley
 *
 */
public class TestStoreData &#123;
    public static void main(String[] args) &#123;
        Map&lt;String,Object&gt; row1 = new HashMap&lt;&gt;();
        row1.put(&quot;id&quot;, 1001);
        row1.put(&quot;姓名&quot;, &quot;张三&quot;);
        row1.put(&quot;薪水&quot;, 20000);
        row1.put(&quot;入职日期&quot;, &quot;2018.5.5&quot;);
        
        Map&lt;String,Object&gt; row2 = new HashMap&lt;&gt;();
        row2.put(&quot;id&quot;, 1002);
        row2.put(&quot;姓名&quot;, &quot;李四&quot;);
        row2.put(&quot;薪水&quot;, 30000);
        row2.put(&quot;入职日期&quot;, &quot;2005.4.4&quot;);
        
        Map&lt;String,Object&gt; row3 = new HashMap&lt;&gt;();
        row3.put(&quot;id&quot;, 1003);
        row3.put(&quot;姓名&quot;, &quot;王五&quot;);
        row3.put(&quot;薪水&quot;, 3000);
        row3.put(&quot;入职日期&quot;, &quot;2020.5.4&quot;);
        
        List&lt;Map&lt;String,Object&gt;&gt; table1 = new ArrayList&lt;&gt;();
        table1.add(row1);
        table1.add(row2);
        table1.add(row3);
        
        for(Map&lt;String,Object&gt; row:table1) &#123;
            Set&lt;String&gt; keyset = row.keySet();
            for(String key:keyset) &#123;
                System.out.print(key+&quot;:&quot;+row.get(key)+&quot;\t&quot;);
            &#125;
            System.out.println();
        &#125;
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">姓名:张三    薪水:20000    id:1001    入职日期:2018.5.5    
姓名:李四    薪水:30000    id:1002    入职日期:2005.4.4    
姓名:王五    薪水:3000    id:1003    入职日期:2020.5.4    
</code></pre>
<h2 id="JavaBean和List结合存储"><a href="#JavaBean和List结合存储" class="headerlink" title="JavaBean和List结合存储"></a>JavaBean和List结合存储</h2><p>每一行数据使用JavaBean对象存储，多行使用放到Map或List中。代码如下：</p>
<pre><code class="java">package com.msl.collection;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * 测试表格数据的存储
 * 体会ORM思想
 * 每一行数据使用javabean对象存储，多行使用放到map或list中
 * @author Senley
 *
 */
public class TestStoreData2 &#123;
    public static void main(String[] args) &#123;
        User user1 = new User(1001,&quot;张三&quot;,20000,&quot;2018.5.5&quot;);
        User user2 = new User(1002,&quot;李四&quot;,30000,&quot;2005.5.4&quot;);
        User user3 = new User(1003,&quot;王五&quot;,3000,&quot;2020.5.4&quot;);
        
        List&lt;User&gt; list = new ArrayList&lt;&gt;();
        list.add(user1);
        list.add(user2);
        list.add(user3);
        for(User u:list) &#123;
            System.out.println(u);
        &#125;
        
        Map&lt;Integer,User&gt; map = new HashMap&lt;&gt;();
        map.put(1001, user1);
        map.put(1002, user2);
        map.put(1003, user3);
        Set&lt;Integer&gt; keyset = map.keySet();
        for(Integer key:keyset) &#123;
            System.out.println(key+&quot;====&quot;+map.get(key));
        &#125;
    &#125;
&#125;

class User&#123;
    private int id;
    private String name;
    private double salary;
    private String hiredate;
    
    //一个完整的javabean要有set和get方法以及一个无参构造器
    public User() &#123;
    &#125;
    
    public User(int id, String name, double salary, String hiredate) &#123;
        super();
        this.id = id;
        this.name = name;
        this.salary = salary;
        this.hiredate = hiredate;
    &#125;
    
    public int getId() &#123;
        return id;
    &#125;
    public void setId(int id) &#123;
        this.id = id;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public double getSalary() &#123;
        return salary;
    &#125;
    public void setSalary(double salary) &#123;
        this.salary = salary;
    &#125;
    public String getHiredate() &#123;
        return hiredate;
    &#125;
    public void setHiredate(String hiredate) &#123;
        this.hiredate = hiredate;
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;id:&quot;+id+&quot;,name:&quot;+name+&quot;,salary:&quot;+salary+&quot;,hiredate:&quot;+hiredate;
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">id:1001,name:张三,salary:20000.0,hiredate:2018.5.5
id:1002,name:李四,salary:30000.0,hiredate:2005.5.4
id:1003,name:王五,salary:3000.0,hiredate:2020.5.4
1001====id:1001,name:张三,salary:20000.0,hiredate:2018.5.5
1002====id:1002,name:李四,salary:30000.0,hiredate:2005.5.4
1003====id:1003,name:王五,salary:3000.0,hiredate:2020.5.4
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/StoreData/" rel="tag">StoreData</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-遍历集合的方法总结"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/21/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"
    >遍历集合的方法总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/21/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2021-11-21T13:09:08.000Z" itemprop="datePublished">2021-11-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="遍历集合-容器-的方法总结"><a href="#遍历集合-容器-的方法总结" class="headerlink" title="遍历集合(容器)的方法总结"></a><strong>遍历集合(容器)的方法总结</strong></h1><h2 id="使用Iterator迭代器遍历容器元素"><a href="#使用Iterator迭代器遍历容器元素" class="headerlink" title="使用Iterator迭代器遍历容器元素"></a>使用Iterator迭代器遍历容器元素</h2><h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><p>Java集合框架的集合类，我们有时候称之为容器。容器的种类有很多种，如ArrayList、LinkedList、HashSet…，每种容器都有自己的特点，ArrayList底层维护的是一个数组；LinkedList是链表结构；HashSet依赖的是哈希表，每种容器都有自己特有的数据结构。</p>
<p>因为容器的内部结构不同，很多时候可能不知道该怎样去遍历一个容器中的元素。所以为了使对容器内元素的操作更为简单，Java引入了迭代器模式。</p>
<p><strong>把访问逻辑从不同类型的集合类中抽取出来，从而避免向外部暴露集合的内部结构。</strong></p>
<p>使用Iterator遍历List、Set、Map，代码如下：</p>
<pre><code class="java">package com.msl.collection;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * 测试迭代器遍历集合
 * @author Senley
 *
 */
public class TestIterator &#123;
    public static void main(String[] args) &#123;
        testIteratorList();
        testIteratorSet();
        testIteratorMap();
    &#125;
    
    public static void testIteratorList() &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;aa&quot;);
        list.add(&quot;bb&quot;);
        list.add(&quot;cc&quot;);
        
        //使用Iterator遍历List
        for(Iterator&lt;String&gt; iter=list.iterator();iter.hasNext();) &#123;
            String temp = iter.next();
            System.out.println(temp);
        &#125;
    &#125;
    
    public static void testIteratorSet() &#123;
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        set.add(&quot;aa&quot;);
        set.add(&quot;bb&quot;);
        set.add(&quot;cc&quot;);
        
        //使用Iterator遍历Set
        for(Iterator&lt;String&gt; iter=set.iterator();iter.hasNext();) &#123;
            String temp = iter.next();
            System.out.println(temp);
        &#125;
    &#125;
    
    public static void testIteratorMap() &#123;
        Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;();
        map.put(100,&quot;aa&quot;);
        map.put(200,&quot;bb&quot;);
        map.put(300,&quot;cc&quot;);
        
        //使用Iterator遍历Map，第一种方式
        Set&lt;Entry&lt;Integer,String&gt;&gt; ss = map.entrySet();
        for(Iterator&lt;Entry&lt;Integer,String&gt;&gt; iter=ss.iterator();iter.hasNext();) &#123;
            Entry&lt;Integer,String&gt; temp = iter.next();
            System.out.println(temp.getKey()+&quot;---&quot;+temp.getValue());
        &#125;
        
        //使用Iterator遍历Map，第二种方式
        Set&lt;Integer&gt; keySet = map.keySet();
        for(Iterator&lt;Integer&gt; iter=keySet.iterator();iter.hasNext();) &#123;
            Integer key = iter.next();
            System.out.println(key+&quot;---&quot;+map.get(key));
        &#125;
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">aa
bb
cc
aa
bb
cc
100---aa
200---bb
300---cc
100---aa
200---bb
300---cc
</code></pre>
<h2 id="遍历集合-容器-的方法"><a href="#遍历集合-容器-的方法" class="headerlink" title="遍历集合(容器)的方法"></a>遍历集合(容器)的方法</h2><h3 id="遍历List方法一：普通for循环"><a href="#遍历List方法一：普通for循环" class="headerlink" title="遍历List方法一：普通for循环"></a>遍历List方法一：普通for循环</h3><pre><code class="java">for(int i=0;i&lt;list.size();i++)&#123;//list为集合的对象名
    String temp = (String)list.get(i);
    System.out.println(temp);
&#125;
</code></pre>
<h3 id="遍历List方法二：增强for循环"><a href="#遍历List方法二：增强for循环" class="headerlink" title="遍历List方法二：增强for循环"></a>遍历List方法二：增强for循环</h3><pre><code class="java">for (String temp : list) &#123;
    System.out.println(temp);
&#125;
</code></pre>
<h3 id="遍历List方法三：使用Iterator迭代器-1"><a href="#遍历List方法三：使用Iterator迭代器-1" class="headerlink" title="遍历List方法三：使用Iterator迭代器(1)"></a>遍历List方法三：使用Iterator迭代器(1)</h3><pre><code class="java">for(Iterator iter = list.iterator();iter.hasNext();)&#123;
    String temp = (String)iter.next();
    System.out.println(temp);
&#125;
</code></pre>
<h3 id="遍历List方法四：使用Iterator迭代器-2"><a href="#遍历List方法四：使用Iterator迭代器-2" class="headerlink" title="遍历List方法四：使用Iterator迭代器(2)"></a>遍历List方法四：使用Iterator迭代器(2)</h3><pre><code class="java">Iterator iter = list.iterator();
while(iter.hasNext())&#123;
    Object  obj = iter.next();
    iter.remove();//如果要遍历时，删除集合中的元素，建议使用这种方式
    System.out.println(obj);
&#125;
</code></pre>
<h3 id="遍历Set方法一：增强for循环"><a href="#遍历Set方法一：增强for循环" class="headerlink" title="遍历Set方法一：增强for循环"></a>遍历Set方法一：增强for循环</h3><pre><code class="java">for(String temp:set)&#123;
    System.out.println(temp);
&#125;
</code></pre>
<h3 id="遍历Set方法二：使用Iterator迭代器"><a href="#遍历Set方法二：使用Iterator迭代器" class="headerlink" title="遍历Set方法二：使用Iterator迭代器"></a>遍历Set方法二：使用Iterator迭代器</h3><pre><code class="java">for(Iterator iter = set.iterator();iter.hasNext();)&#123;
    String temp = (String)iter.next();
    System.out.println(temp);
&#125;
</code></pre>
<h3 id="遍历Map方法一：根据key获取value"><a href="#遍历Map方法一：根据key获取value" class="headerlink" title="遍历Map方法一：根据key获取value"></a>遍历Map方法一：根据key获取value</h3><pre><code class="java">Map&lt;Integer, Man&gt; maps = new HashMap&lt;Integer, Man&gt;();
Set&lt;Integer&gt; keySet = maps.keySet();
for(Integer id : keySet)&#123;
    System.out.println(maps.get(id).name);
&#125;
</code></pre>
<h3 id="遍历Map方法二：使用entrySet"><a href="#遍历Map方法二：使用entrySet" class="headerlink" title="遍历Map方法二：使用entrySet"></a>遍历Map方法二：使用entrySet</h3><pre><code class="java">Set&lt;Entry&lt;Integer, Man&gt;&gt; ss = maps.entrySet();
for (Iterator iterator = ss.iterator(); iterator.hasNext();) &#123;
    Entry e = (Entry) iterator.next(); 
    System.out.println(e.getKey()+&quot;--&quot;+e.getValue());
&#125;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/" rel="tag">Collection</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-自定义一个HashSet"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/18/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAHashSet/"
    >自定义一个HashSet</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/18/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAHashSet/" class="article-date">
  <time datetime="2021-11-18T14:05:03.000Z" itemprop="datePublished">2021-11-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="自定义一个HashSet"><a href="#自定义一个HashSet" class="headerlink" title="自定义一个HashSet"></a>自定义一个HashSet</h1><h2 id="HashSet特点和底层实现"><a href="#HashSet特点和底层实现" class="headerlink" title="HashSet特点和底层实现"></a>HashSet特点和底层实现</h2><ul>
<li><p>HashSet底层是HashMap；</p>
</li>
<li><p>向Hashset中添加元素, 实际上是把这个元素作为键添加到底层的HashMap中；</p>
</li>
<li><p>HashSet实际上就是底层HashMap的键的集合。</p>
</li>
</ul>
<p> HashSet是采用哈希算法实现，底层实际是用HashMap实现的(HashSet本质就是一个简化版的HashMap)，因此，查询效率和增删效率都比较高。查看HashSet的源码：</p>
<pre><code class="java">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123;
    static final long serialVersionUID = -5024744406713321676L;

    private transient HashMap&lt;E,Object&gt; map;

    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();

    /**
     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has
     * default initial capacity (16) and load factor (0.75).
     */
    public HashSet() &#123;
        map = new HashMap&lt;&gt;();
    &#125;
    
     /**
     * Adds the specified element to this set if it is not already present.
     * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if
     * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that
     * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.
     * If this set already contains the element, the call leaves the set
     * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.
     *
     * @param e element to be added to this set
     * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified
     * element
     */
    public boolean add(E e) &#123;
        return map.put(e, PRESENT)==null;
    &#125;
    //以下代码省略
&#125;
</code></pre>
<p>可以发现里面有个map属性，这就是HashSet的核心秘密。再看add()方法，可以发现增加一个元素，说白了就是在map中增加一个键值对，键对象就是这个元素，值对象是名为PRESENT的Object对象。说白了就是“往set中加入元素，本质就是把这个元素作为key加入到了内部的map中”。</p>
<p>由于map中key都是不可重复的，因此，Set天然具有“不可重复”的特性。</p>
<h2 id="自定义一个HashSet，体会底层原理"><a href="#自定义一个HashSet，体会底层原理" class="headerlink" title="自定义一个HashSet，体会底层原理"></a>自定义一个HashSet，体会底层原理</h2><p>代码如下：</p>
<pre><code class="java">package com.msl.mycollection;

import java.util.HashMap;

/**
 * 手动实现一个HashSet，深刻理解HashSet底层原理
 * @author Senley
 *
 */
public class MslHashSet &#123;
    HashMap map;
    private static final Object PRESENT = new Object();
    
    public static void main(String[] args) &#123;
        MslHashSet set = new MslHashSet();
        set.add(&quot;aaa&quot;);
        set.add(&quot;bbb&quot;);
        set.add(&quot;ccc&quot;);
        System.out.println(set);
    &#125;
    
    public MslHashSet()&#123;
        map = new HashMap();
    &#125;
    
    public int size() &#123;
        return map.size();
    &#125;
    
    public void add(Object o) &#123;
        map.put(o, PRESENT);
    &#125;
    
    @Override
    public String toString() &#123;
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;[&quot;);
        for(Object key:map.keySet()) &#123;
            sb.append(key+&quot;,&quot;);
        &#125;
        sb.setCharAt(sb.length()-1, &#39;]&#39;);
        return sb.toString();
    &#125;
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="java">[aaa,ccc,bbb]
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HashSet/" rel="tag">HashSet</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2022
        <i class="ri-heart-fill heart_icon"></i> Senley
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/favicon.ico" alt="senleima"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/senleima/imagebed/img/wechatpay.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>